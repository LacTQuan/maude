
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Test Results</title>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/themes/prism-okaidia.min.css" rel="stylesheet" />
        <style>
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                margin: 20px;
            }
            table {
                border-collapse: collapse;
                width: 100%;
                box-shadow: 0 2px 3px rgba(0,0,0,0.1);
            }
            th, td {
                border: 1px solid #ddd;
                text-align: left;
                padding: 8px;
            }
            th {
                background-color: #f2f2f2;
            }
            tr:nth-child(even) {
                background-color: #f9f9f9;
            }
            .status-pass {
                color: green;
            }
            .status-fail {
                color: red;
            }
            pre {
                background-color: #282c34 !important;
                color: #ffffff !important;
                padding: 10px;
                border-radius: 5px;
                overflow-x: auto;
                white-space: pre-wrap;
                font-family: 'Courier New', Courier, monospace;
                font-size: 1.1em;  /* Slightly larger font size */
            }
        </style>
    </head>
    <body>
        <table>
            <tr>
                <th>Status</th>
                <th>Reason</th>
                <th>Exit Code</th>
                <th>Language</th>
                <th>Modified Test File</th>
                <th>Details</th>
            </tr>
            
            <tr>
                <td class="status-FAIL">FAIL</td>
                <td>Test failed</td>
                <td>1</td>
                <td>python</td>
                <td>
                    <details>
                        <summary>View Full Code</summary>
                        <pre><code><span class="diff-unchanged">  import pytest</span>
<span class="diff-unchanged">  from app import Node, Dijkstra</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_simple_path():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 1:</span>
<span class="diff-unchanged">      A simple 3x3 grid with no obstacles. The start is at (0,0) and the goal is at (2,2).</span>
<span class="diff-unchanged">      We expect the planner to find a path.</span>
<span class="diff-unchanged">      Note: The returned path is in reverse order (goal to start).</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 0, 0],</span>
<span class="diff-unchanged">          [0, 0, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">      </span>
<span class="diff-unchanged">      assert found is True, "Path should be found in a clear grid."</span>
<span class="diff-unchanged">      # Check that the path starts at the goal and ends at the start.</span>
<span class="diff-unchanged">      assert path[0] == goal, "Path should start with the goal node."</span>
<span class="diff-unchanged">      assert path[-1] == start, "Path should end with the start node."</span>
<span class="diff-unchanged">      # Optionally, check that the length of the path is reasonable (at least Manhattan distance + 1)</span>
<span class="diff-unchanged">      manhattan_distance = abs(goal.x - start.x) + abs(goal.y - start.y)</span>
<span class="diff-unchanged">      assert len(path) >= manhattan_distance + 1</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_no_path():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 2:</span>
<span class="diff-unchanged">      A 3x3 grid where the start is completely blocked off.</span>
<span class="diff-unchanged">      Start is at (0,0) and obstacles are placed so that there is no valid move.</span>
<span class="diff-unchanged">      The planner should return that no path is found.</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [1, 1, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">      assert found is False, "No path should be found if the start is blocked."</span>
<span class="diff-unchanged">      assert path == [], "Path should be empty when no path is found."</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_obstacle_detour():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 3:</span>
<span class="diff-unchanged">      A 3x3 grid with a vertical obstacle in the middle.</span>
<span class="diff-unchanged">      The start is at (0,0) and the goal is at (2,2). A detour is required.</span>
<span class="diff-unchanged">      We expect the planner to find a valid path.</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">      assert found is True, "A path should be found around the obstacle."</span>
<span class="diff-unchanged">      assert path[0] == goal, "Path should start with the goal node."</span>
<span class="diff-unchanged">      assert path[-1] == start, "Path should end with the start node."</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_goal_not_found():</span>
<span class="diff-unchanged">      planner = Dijkstra([[0]])</span>
<span class="diff-unchanged">      closed_list = set()</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(1, 1, 0)</span>
<span class="diff-unchanged">      path = planner.convert_closed_list_to_path(closed_list, start, goal)</span>
<span class="diff-unchanged">      assert path == []</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_node_repr():</span>
<span class="diff-unchanged">      node = Node(1, 2, 3, 4, 5)</span>
<span class="diff-unchanged">      expected_repr = "Node(x=1, y=2, cost=3, id=4, pid=5)"</span>
<span class="diff-unchanged">      assert repr(node) == expected_repr</span>
<span class="diff-added">+ </span>
<span class="diff-added">+ </span>
<span class="diff-added">+ def test_goal_unreachable():</span>
<span class="diff-added">+     n = 3</span>
<span class="diff-added">+     grid = [</span>
<span class="diff-added">+         [0, 1, 0],</span>
<span class="diff-added">+         [0, 1, 0],</span>
<span class="diff-added">+         [0, 1, 0]</span>
<span class="diff-added">+     ]</span>
<span class="diff-added">+     start = Node(0, 0, 0)</span>
<span class="diff-added">+     goal = Node(2, 0, 0)</span>
<span class="diff-added">+     start.id = start.x * n + start.y</span>
<span class="diff-added">+     start.pid = start.id</span>
<span class="diff-added">+     goal.id = goal.x * n + goal.y</span>
<span class="diff-added">+     grid[start.x][start.y] = 0</span>
<span class="diff-added">+     grid[goal.x][goal.y] = 0</span>
<span class="diff-added">+ </span>
<span class="diff-added">+     planner = Dijkstra(grid)</span>
<span class="diff-added">+     found, path = planner.plan(start, goal)</span>
<span class="diff-added">+ </span>
<span class="diff-added">+     assert found is False</span>
<span class="diff-added">+     assert path == []</span></code></pre>
                    </details>
                </td>
                <td>
                    <details>
                        <summary>View More</summary>
                        <div><strong>STDERR:</strong> <pre><code class="language-python"></code></pre></div>
                        <div><strong>STDOUT:</strong> <pre><code class="language-python">============================= test session starts ==============================
platform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0
rootdir: /home/thiuquan/code/maude/cover-agent/dijkstra
plugins: anyio-4.8.0, cov-6.0.0
collected 6 items

test_app.py .....F                                                       [100%]

=================================== FAILURES ===================================
____________________________ test_goal_unreachable _____________________________

    def test_goal_unreachable():
        n = 3
        grid = [
            [0, 1, 0],
            [0, 1, 0],
            [0, 1, 0]
        ]
        start = Node(0, 0, 0)
        goal = Node(2, 0, 0)
        start.id = start.x * n + start.y
        start.pid = start.id
        goal.id = goal.x * n + goal.y
        grid[start.x][start.y] = 0
        grid[goal.x][goal.y] = 0
    
        planner = Dijkstra(grid)
        found, path = planner.plan(start, goal)
    
>       assert found is False
E       assert True is False

test_app.py:104: AssertionError

---------- coverage: platform linux, python 3.10.12-final-0 ----------
Name          Stmts   Miss Branch BrPart  Cover
-----------------------------------------------
app.py          106     17     32      3    86%
test_app.py      55      1      0      0    98%
-----------------------------------------------
TOTAL           161     18     32      3    89%
Coverage XML written to file coverage.xml

=========================== short test summary info ============================
FAILED test_app.py::test_goal_unreachable - assert True is False
========================= 1 failed, 5 passed in 0.08s ==========================
</code></pre></div>
                        <div><strong>Test Code:</strong> <pre><code class="language-python">def test_goal_unreachable():
    n = 3
    grid = [
        [0, 1, 0],
        [0, 1, 0],
        [0, 1, 0]
    ]
    start = Node(0, 0, 0)
    goal = Node(2, 0, 0)
    start.id = start.x * n + start.y
    start.pid = start.id
    goal.id = goal.x * n + goal.y
    grid[start.x][start.y] = 0
    grid[goal.x][goal.y] = 0

    planner = Dijkstra(grid)
    found, path = planner.plan(start, goal)

    assert found is False
    assert path == []
</code></pre></div>
                        <div><strong>Imports:</strong> <pre><code class="language-python">""
</code></pre></div>
                    </details>
                </td>
            </tr>
            
            <tr>
                <td class="status-FAIL">FAIL</td>
                <td>Test failed</td>
                <td>1</td>
                <td>python</td>
                <td>
                    <details>
                        <summary>View Full Code</summary>
                        <pre><code><span class="diff-unchanged">  import pytest</span>
<span class="diff-unchanged">  from app import Node, Dijkstra</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_simple_path():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 1:</span>
<span class="diff-unchanged">      A simple 3x3 grid with no obstacles. The start is at (0,0) and the goal is at (2,2).</span>
<span class="diff-unchanged">      We expect the planner to find a path.</span>
<span class="diff-unchanged">      Note: The returned path is in reverse order (goal to start).</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 0, 0],</span>
<span class="diff-unchanged">          [0, 0, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">      </span>
<span class="diff-unchanged">      assert found is True, "Path should be found in a clear grid."</span>
<span class="diff-unchanged">      # Check that the path starts at the goal and ends at the start.</span>
<span class="diff-unchanged">      assert path[0] == goal, "Path should start with the goal node."</span>
<span class="diff-unchanged">      assert path[-1] == start, "Path should end with the start node."</span>
<span class="diff-unchanged">      # Optionally, check that the length of the path is reasonable (at least Manhattan distance + 1)</span>
<span class="diff-unchanged">      manhattan_distance = abs(goal.x - start.x) + abs(goal.y - start.y)</span>
<span class="diff-unchanged">      assert len(path) >= manhattan_distance + 1</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_no_path():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 2:</span>
<span class="diff-unchanged">      A 3x3 grid where the start is completely blocked off.</span>
<span class="diff-unchanged">      Start is at (0,0) and obstacles are placed so that there is no valid move.</span>
<span class="diff-unchanged">      The planner should return that no path is found.</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [1, 1, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">      assert found is False, "No path should be found if the start is blocked."</span>
<span class="diff-unchanged">      assert path == [], "Path should be empty when no path is found."</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_obstacle_detour():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 3:</span>
<span class="diff-unchanged">      A 3x3 grid with a vertical obstacle in the middle.</span>
<span class="diff-unchanged">      The start is at (0,0) and the goal is at (2,2). A detour is required.</span>
<span class="diff-unchanged">      We expect the planner to find a valid path.</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">      assert found is True, "A path should be found around the obstacle."</span>
<span class="diff-unchanged">      assert path[0] == goal, "Path should start with the goal node."</span>
<span class="diff-unchanged">      assert path[-1] == start, "Path should end with the start node."</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_goal_not_found():</span>
<span class="diff-unchanged">      planner = Dijkstra([[0]])</span>
<span class="diff-unchanged">      closed_list = set()</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(1, 1, 0)</span>
<span class="diff-unchanged">      path = planner.convert_closed_list_to_path(closed_list, start, goal)</span>
<span class="diff-unchanged">      assert path == []</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_node_repr():</span>
<span class="diff-unchanged">      node = Node(1, 2, 3, 4, 5)</span>
<span class="diff-unchanged">      expected_repr = "Node(x=1, y=2, cost=3, id=4, pid=5)"</span>
<span class="diff-unchanged">      assert repr(node) == expected_repr</span>
<span class="diff-added">+ </span>
<span class="diff-added">+ </span>
<span class="diff-added">+ def test_convert_closed_list_no_parent():</span>
<span class="diff-added">+     planner = Dijkstra([[0]])</span>
<span class="diff-added">+     closed_list = {Node(0, 0), Node(0, 1)}</span>
<span class="diff-added">+     start = Node(0, 0, 0)</span>
<span class="diff-added">+     goal = Node(0, 1, 0)</span>
<span class="diff-added">+     goal.pid = 5  # Invalid pid</span>
<span class="diff-added">+     path = planner.convert_closed_list_to_path(closed_list, start, goal)</span>
<span class="diff-added">+     assert path == []</span></code></pre>
                    </details>
                </td>
                <td>
                    <details>
                        <summary>View More</summary>
                        <div><strong>STDERR:</strong> <pre><code class="language-python"></code></pre></div>
                        <div><strong>STDOUT:</strong> <pre><code class="language-python">============================= test session starts ==============================
platform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0
rootdir: /home/thiuquan/code/maude/cover-agent/dijkstra
plugins: anyio-4.8.0, cov-6.0.0
collected 6 items

test_app.py .....F                                                       [100%]

=================================== FAILURES ===================================
______________________ test_convert_closed_list_no_parent ______________________

    def test_convert_closed_list_no_parent():
        planner = Dijkstra([[0]])
        closed_list = {Node(0, 0), Node(0, 1)}
        start = Node(0, 0, 0)
        goal = Node(0, 1, 0)
        goal.pid = 5  # Invalid pid
>       path = planner.convert_closed_list_to_path(closed_list, start, goal)

test_app.py:92: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <app.Dijkstra object at 0x7fd9d3fa8b50>
closed_list = {Node(x=0, y=1, cost=0, id=None, pid=None), Node(x=0, y=0, cost=0, id=None, pid=None)}
start = Node(x=0, y=0, cost=0, id=None, pid=None)
goal = Node(x=0, y=1, cost=0, id=None, pid=5)

    def convert_closed_list_to_path(self, closed_list, start, goal):
        """
        Converts the closed list (visited nodes) into a path from goal to start.
        Backtracks from the goal node using the stored parent ids (pid).
        """
        current = None
        # Find the node in closed_list that matches the goal coordinates.
        for node in closed_list:
            if compare_coordinates(node, goal):
                current = node
                break
    
        if current is None:
            print("Error in calculating path")
            return []
    
        path = []
        # Backtrack until we reach the start.
        while not compare_coordinates(current, start):
            path.append(current)
>           parent_x = current.pid // self.n
E           TypeError: unsupported operand type(s) for //: 'NoneType' and 'int'

app.py:144: TypeError

---------- coverage: platform linux, python 3.10.12-final-0 ----------
Name          Stmts   Miss Branch BrPart  Cover
-----------------------------------------------
app.py          106     17     32      3    86%
test_app.py      49      1      0      0    98%
-----------------------------------------------
TOTAL           155     18     32      3    89%
Coverage XML written to file coverage.xml

=========================== short test summary info ============================
FAILED test_app.py::test_convert_closed_list_no_parent - TypeError: unsupport...
========================= 1 failed, 5 passed in 0.09s ==========================
</code></pre></div>
                        <div><strong>Test Code:</strong> <pre><code class="language-python">def test_convert_closed_list_no_parent():
    planner = Dijkstra([[0]])
    closed_list = {Node(0, 0), Node(0, 1)}
    start = Node(0, 0, 0)
    goal = Node(0, 1, 0)
    goal.pid = 5  # Invalid pid
    path = planner.convert_closed_list_to_path(closed_list, start, goal)
    assert path == []
</code></pre></div>
                        <div><strong>Imports:</strong> <pre><code class="language-python">""
</code></pre></div>
                    </details>
                </td>
            </tr>
            
            <tr>
                <td class="status-FAIL">FAIL</td>
                <td>Test failed</td>
                <td>1</td>
                <td>python</td>
                <td>
                    <details>
                        <summary>View Full Code</summary>
                        <pre><code><span class="diff-unchanged">  import pytest</span>
<span class="diff-unchanged">  from app import Node, Dijkstra</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_simple_path():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 1:</span>
<span class="diff-unchanged">      A simple 3x3 grid with no obstacles. The start is at (0,0) and the goal is at (2,2).</span>
<span class="diff-unchanged">      We expect the planner to find a path.</span>
<span class="diff-unchanged">      Note: The returned path is in reverse order (goal to start).</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 0, 0],</span>
<span class="diff-unchanged">          [0, 0, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">      </span>
<span class="diff-unchanged">      assert found is True, "Path should be found in a clear grid."</span>
<span class="diff-unchanged">      # Check that the path starts at the goal and ends at the start.</span>
<span class="diff-unchanged">      assert path[0] == goal, "Path should start with the goal node."</span>
<span class="diff-unchanged">      assert path[-1] == start, "Path should end with the start node."</span>
<span class="diff-unchanged">      # Optionally, check that the length of the path is reasonable (at least Manhattan distance + 1)</span>
<span class="diff-unchanged">      manhattan_distance = abs(goal.x - start.x) + abs(goal.y - start.y)</span>
<span class="diff-unchanged">      assert len(path) >= manhattan_distance + 1</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_no_path():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 2:</span>
<span class="diff-unchanged">      A 3x3 grid where the start is completely blocked off.</span>
<span class="diff-unchanged">      Start is at (0,0) and obstacles are placed so that there is no valid move.</span>
<span class="diff-unchanged">      The planner should return that no path is found.</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [1, 1, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">      assert found is False, "No path should be found if the start is blocked."</span>
<span class="diff-unchanged">      assert path == [], "Path should be empty when no path is found."</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_obstacle_detour():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 3:</span>
<span class="diff-unchanged">      A 3x3 grid with a vertical obstacle in the middle.</span>
<span class="diff-unchanged">      The start is at (0,0) and the goal is at (2,2). A detour is required.</span>
<span class="diff-unchanged">      We expect the planner to find a valid path.</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">      assert found is True, "A path should be found around the obstacle."</span>
<span class="diff-unchanged">      assert path[0] == goal, "Path should start with the goal node."</span>
<span class="diff-unchanged">      assert path[-1] == start, "Path should end with the start node."</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_goal_not_found():</span>
<span class="diff-unchanged">      planner = Dijkstra([[0]])</span>
<span class="diff-unchanged">      closed_list = set()</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(1, 1, 0)</span>
<span class="diff-unchanged">      path = planner.convert_closed_list_to_path(closed_list, start, goal)</span>
<span class="diff-unchanged">      assert path == []</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_node_repr():</span>
<span class="diff-unchanged">      node = Node(1, 2, 3, 4, 5)</span>
<span class="diff-unchanged">      expected_repr = "Node(x=1, y=2, cost=3, id=4, pid=5)"</span>
<span class="diff-unchanged">      assert repr(node) == expected_repr</span>
<span class="diff-added">+ </span>
<span class="diff-added">+ </span>
<span class="diff-added">+ def test_goal_unreachable():</span>
<span class="diff-added">+     n = 3</span>
<span class="diff-added">+     grid = [</span>
<span class="diff-added">+         [0, 1, 0],</span>
<span class="diff-added">+         [0, 1, 0],</span>
<span class="diff-added">+         [0, 1, 0]</span>
<span class="diff-added">+     ]</span>
<span class="diff-added">+     start = Node(0, 0, 0)</span>
<span class="diff-added">+     goal = Node(2, 0, 0)</span>
<span class="diff-added">+     start.id = start.x * n + start.y</span>
<span class="diff-added">+     start.pid = start.id</span>
<span class="diff-added">+     goal.id = goal.x * n + goal.y</span>
<span class="diff-added">+     grid[start.x][start.y] = 0</span>
<span class="diff-added">+     grid[goal.x][goal.y] = 0</span>
<span class="diff-added">+ </span>
<span class="diff-added">+     planner = Dijkstra(grid)</span>
<span class="diff-added">+     found, path = planner.plan(start, goal)</span>
<span class="diff-added">+ </span>
<span class="diff-added">+     assert found is False</span>
<span class="diff-added">+     assert path == []</span></code></pre>
                    </details>
                </td>
                <td>
                    <details>
                        <summary>View More</summary>
                        <div><strong>STDERR:</strong> <pre><code class="language-python"></code></pre></div>
                        <div><strong>STDOUT:</strong> <pre><code class="language-python">============================= test session starts ==============================
platform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0
rootdir: /home/thiuquan/code/maude/cover-agent/dijkstra
plugins: anyio-4.8.0, cov-6.0.0
collected 6 items

test_app.py .....F                                                       [100%]

=================================== FAILURES ===================================
____________________________ test_goal_unreachable _____________________________

    def test_goal_unreachable():
        n = 3
        grid = [
            [0, 1, 0],
            [0, 1, 0],
            [0, 1, 0]
        ]
        start = Node(0, 0, 0)
        goal = Node(2, 0, 0)
        start.id = start.x * n + start.y
        start.pid = start.id
        goal.id = goal.x * n + goal.y
        grid[start.x][start.y] = 0
        grid[goal.x][goal.y] = 0
    
        planner = Dijkstra(grid)
        found, path = planner.plan(start, goal)
    
>       assert found is False
E       assert True is False

test_app.py:104: AssertionError

---------- coverage: platform linux, python 3.10.12-final-0 ----------
Name          Stmts   Miss Branch BrPart  Cover
-----------------------------------------------
app.py          106     17     32      3    86%
test_app.py      55      1      0      0    98%
-----------------------------------------------
TOTAL           161     18     32      3    89%
Coverage XML written to file coverage.xml

=========================== short test summary info ============================
FAILED test_app.py::test_goal_unreachable - assert True is False
========================= 1 failed, 5 passed in 0.08s ==========================
</code></pre></div>
                        <div><strong>Test Code:</strong> <pre><code class="language-python">def test_goal_unreachable():
    n = 3
    grid = [
        [0, 1, 0],
        [0, 1, 0],
        [0, 1, 0]
    ]
    start = Node(0, 0, 0)
    goal = Node(2, 0, 0)
    start.id = start.x * n + start.y
    start.pid = start.id
    goal.id = goal.x * n + goal.y
    grid[start.x][start.y] = 0
    grid[goal.x][goal.y] = 0

    planner = Dijkstra(grid)
    found, path = planner.plan(start, goal)

    assert found is False
    assert path == []
</code></pre></div>
                        <div><strong>Imports:</strong> <pre><code class="language-python">""
</code></pre></div>
                    </details>
                </td>
            </tr>
            
            <tr>
                <td class="status-FAIL">FAIL</td>
                <td>Test failed</td>
                <td>1</td>
                <td>python</td>
                <td>
                    <details>
                        <summary>View Full Code</summary>
                        <pre><code><span class="diff-unchanged">  import pytest</span>
<span class="diff-unchanged">  from app import Node, Dijkstra</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_simple_path():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 1:</span>
<span class="diff-unchanged">      A simple 3x3 grid with no obstacles. The start is at (0,0) and the goal is at (2,2).</span>
<span class="diff-unchanged">      We expect the planner to find a path.</span>
<span class="diff-unchanged">      Note: The returned path is in reverse order (goal to start).</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 0, 0],</span>
<span class="diff-unchanged">          [0, 0, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">      </span>
<span class="diff-unchanged">      assert found is True, "Path should be found in a clear grid."</span>
<span class="diff-unchanged">      # Check that the path starts at the goal and ends at the start.</span>
<span class="diff-unchanged">      assert path[0] == goal, "Path should start with the goal node."</span>
<span class="diff-unchanged">      assert path[-1] == start, "Path should end with the start node."</span>
<span class="diff-unchanged">      # Optionally, check that the length of the path is reasonable (at least Manhattan distance + 1)</span>
<span class="diff-unchanged">      manhattan_distance = abs(goal.x - start.x) + abs(goal.y - start.y)</span>
<span class="diff-unchanged">      assert len(path) >= manhattan_distance + 1</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_no_path():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 2:</span>
<span class="diff-unchanged">      A 3x3 grid where the start is completely blocked off.</span>
<span class="diff-unchanged">      Start is at (0,0) and obstacles are placed so that there is no valid move.</span>
<span class="diff-unchanged">      The planner should return that no path is found.</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [1, 1, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">      assert found is False, "No path should be found if the start is blocked."</span>
<span class="diff-unchanged">      assert path == [], "Path should be empty when no path is found."</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_obstacle_detour():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 3:</span>
<span class="diff-unchanged">      A 3x3 grid with a vertical obstacle in the middle.</span>
<span class="diff-unchanged">      The start is at (0,0) and the goal is at (2,2). A detour is required.</span>
<span class="diff-unchanged">      We expect the planner to find a valid path.</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">      assert found is True, "A path should be found around the obstacle."</span>
<span class="diff-unchanged">      assert path[0] == goal, "Path should start with the goal node."</span>
<span class="diff-unchanged">      assert path[-1] == start, "Path should end with the start node."</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_goal_not_found():</span>
<span class="diff-unchanged">      planner = Dijkstra([[0]])</span>
<span class="diff-unchanged">      closed_list = set()</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(1, 1, 0)</span>
<span class="diff-unchanged">      path = planner.convert_closed_list_to_path(closed_list, start, goal)</span>
<span class="diff-unchanged">      assert path == []</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_node_repr():</span>
<span class="diff-unchanged">      node = Node(1, 2, 3, 4, 5)</span>
<span class="diff-unchanged">      expected_repr = "Node(x=1, y=2, cost=3, id=4, pid=5)"</span>
<span class="diff-unchanged">      assert repr(node) == expected_repr</span>
<span class="diff-added">+ </span>
<span class="diff-added">+ </span>
<span class="diff-added">+ def test_convert_closed_list_no_parent():</span>
<span class="diff-added">+     planner = Dijkstra([[0]])</span>
<span class="diff-added">+     closed_list = {Node(0, 0), Node(0, 1)}</span>
<span class="diff-added">+     start = Node(0, 0, 0)</span>
<span class="diff-added">+     goal = Node(0, 1, 0)</span>
<span class="diff-added">+     goal.pid = None  # Invalid pid</span>
<span class="diff-added">+     path = planner.convert_closed_list_to_path(closed_list, start, goal)</span>
<span class="diff-added">+     assert path == []</span></code></pre>
                    </details>
                </td>
                <td>
                    <details>
                        <summary>View More</summary>
                        <div><strong>STDERR:</strong> <pre><code class="language-python"></code></pre></div>
                        <div><strong>STDOUT:</strong> <pre><code class="language-python">============================= test session starts ==============================
platform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0
rootdir: /home/thiuquan/code/maude/cover-agent/dijkstra
plugins: anyio-4.8.0, cov-6.0.0
collected 6 items

test_app.py .....F                                                       [100%]

=================================== FAILURES ===================================
______________________ test_convert_closed_list_no_parent ______________________

    def test_convert_closed_list_no_parent():
        planner = Dijkstra([[0]])
        closed_list = {Node(0, 0), Node(0, 1)}
        start = Node(0, 0, 0)
        goal = Node(0, 1, 0)
        goal.pid = None  # Invalid pid
>       path = planner.convert_closed_list_to_path(closed_list, start, goal)

test_app.py:92: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <app.Dijkstra object at 0x7fcd38634b50>
closed_list = {Node(x=0, y=1, cost=0, id=None, pid=None), Node(x=0, y=0, cost=0, id=None, pid=None)}
start = Node(x=0, y=0, cost=0, id=None, pid=None)
goal = Node(x=0, y=1, cost=0, id=None, pid=None)

    def convert_closed_list_to_path(self, closed_list, start, goal):
        """
        Converts the closed list (visited nodes) into a path from goal to start.
        Backtracks from the goal node using the stored parent ids (pid).
        """
        current = None
        # Find the node in closed_list that matches the goal coordinates.
        for node in closed_list:
            if compare_coordinates(node, goal):
                current = node
                break
    
        if current is None:
            print("Error in calculating path")
            return []
    
        path = []
        # Backtrack until we reach the start.
        while not compare_coordinates(current, start):
            path.append(current)
>           parent_x = current.pid // self.n
E           TypeError: unsupported operand type(s) for //: 'NoneType' and 'int'

app.py:144: TypeError

---------- coverage: platform linux, python 3.10.12-final-0 ----------
Name          Stmts   Miss Branch BrPart  Cover
-----------------------------------------------
app.py          106     17     32      3    86%
test_app.py      49      1      0      0    98%
-----------------------------------------------
TOTAL           155     18     32      3    89%
Coverage XML written to file coverage.xml

=========================== short test summary info ============================
FAILED test_app.py::test_convert_closed_list_no_parent - TypeError: unsupport...
========================= 1 failed, 5 passed in 0.08s ==========================
</code></pre></div>
                        <div><strong>Test Code:</strong> <pre><code class="language-python">def test_convert_closed_list_no_parent():
    planner = Dijkstra([[0]])
    closed_list = {Node(0, 0), Node(0, 1)}
    start = Node(0, 0, 0)
    goal = Node(0, 1, 0)
    goal.pid = None  # Invalid pid
    path = planner.convert_closed_list_to_path(closed_list, start, goal)
    assert path == []
</code></pre></div>
                        <div><strong>Imports:</strong> <pre><code class="language-python">""
</code></pre></div>
                    </details>
                </td>
            </tr>
            
            <tr>
                <td class="status-FAIL">FAIL</td>
                <td>Coverage did not increase</td>
                <td>0</td>
                <td>python</td>
                <td>
                    <details>
                        <summary>View Full Code</summary>
                        <pre><code><span class="diff-unchanged">  import pytest</span>
<span class="diff-unchanged">  from app import Node, Dijkstra</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_simple_path():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 1:</span>
<span class="diff-unchanged">      A simple 3x3 grid with no obstacles. The start is at (0,0) and the goal is at (2,2).</span>
<span class="diff-unchanged">      We expect the planner to find a path.</span>
<span class="diff-unchanged">      Note: The returned path is in reverse order (goal to start).</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 0, 0],</span>
<span class="diff-unchanged">          [0, 0, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">      </span>
<span class="diff-unchanged">      assert found is True, "Path should be found in a clear grid."</span>
<span class="diff-unchanged">      # Check that the path starts at the goal and ends at the start.</span>
<span class="diff-unchanged">      assert path[0] == goal, "Path should start with the goal node."</span>
<span class="diff-unchanged">      assert path[-1] == start, "Path should end with the start node."</span>
<span class="diff-unchanged">      # Optionally, check that the length of the path is reasonable (at least Manhattan distance + 1)</span>
<span class="diff-unchanged">      manhattan_distance = abs(goal.x - start.x) + abs(goal.y - start.y)</span>
<span class="diff-unchanged">      assert len(path) >= manhattan_distance + 1</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_no_path():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 2:</span>
<span class="diff-unchanged">      A 3x3 grid where the start is completely blocked off.</span>
<span class="diff-unchanged">      Start is at (0,0) and obstacles are placed so that there is no valid move.</span>
<span class="diff-unchanged">      The planner should return that no path is found.</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [1, 1, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">      assert found is False, "No path should be found if the start is blocked."</span>
<span class="diff-unchanged">      assert path == [], "Path should be empty when no path is found."</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_obstacle_detour():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 3:</span>
<span class="diff-unchanged">      A 3x3 grid with a vertical obstacle in the middle.</span>
<span class="diff-unchanged">      The start is at (0,0) and the goal is at (2,2). A detour is required.</span>
<span class="diff-unchanged">      We expect the planner to find a valid path.</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">      assert found is True, "A path should be found around the obstacle."</span>
<span class="diff-unchanged">      assert path[0] == goal, "Path should start with the goal node."</span>
<span class="diff-unchanged">      assert path[-1] == start, "Path should end with the start node."</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_goal_not_found():</span>
<span class="diff-unchanged">      planner = Dijkstra([[0]])</span>
<span class="diff-unchanged">      closed_list = set()</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(1, 1, 0)</span>
<span class="diff-unchanged">      path = planner.convert_closed_list_to_path(closed_list, start, goal)</span>
<span class="diff-unchanged">      assert path == []</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_node_repr():</span>
<span class="diff-unchanged">      node = Node(1, 2, 3, 4, 5)</span>
<span class="diff-unchanged">      expected_repr = "Node(x=1, y=2, cost=3, id=4, pid=5)"</span>
<span class="diff-unchanged">      assert repr(node) == expected_repr</span>
<span class="diff-added">+ </span>
<span class="diff-added">+ </span>
<span class="diff-added">+ def test_start_equals_goal():</span>
<span class="diff-added">+     grid = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]</span>
<span class="diff-added">+     start = Node(1, 1, 0)</span>
<span class="diff-added">+     goal = Node(1, 1, 0)</span>
<span class="diff-added">+     planner = Dijkstra(grid)</span>
<span class="diff-added">+     found, path = planner.plan(start, goal)</span>
<span class="diff-added">+     assert found is True</span>
<span class="diff-added">+     assert path[0] == goal</span>
<span class="diff-added">+     assert path[-1] == start</span></code></pre>
                    </details>
                </td>
                <td>
                    <details>
                        <summary>View More</summary>
                        <div><strong>STDERR:</strong> <pre><code class="language-python"></code></pre></div>
                        <div><strong>STDOUT:</strong> <pre><code class="language-python">============================= test session starts ==============================
platform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0
rootdir: /home/thiuquan/code/maude/cover-agent/dijkstra
plugins: anyio-4.8.0, cov-6.0.0
collected 6 items

test_app.py ......                                                       [100%]

---------- coverage: platform linux, python 3.10.12-final-0 ----------
Name          Stmts   Miss Branch BrPart  Cover
-----------------------------------------------
app.py          106     17     32      3    86%
test_app.py      50      0      0      0   100%
-----------------------------------------------
TOTAL           156     17     32      3    89%
Coverage XML written to file coverage.xml


============================== 6 passed in 0.08s ===============================
</code></pre></div>
                        <div><strong>Test Code:</strong> <pre><code class="language-python">def test_start_equals_goal():
    grid = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]
    start = Node(1, 1, 0)
    goal = Node(1, 1, 0)
    planner = Dijkstra(grid)
    found, path = planner.plan(start, goal)
    assert found is True
    assert path[0] == goal
    assert path[-1] == start
</code></pre></div>
                        <div><strong>Imports:</strong> <pre><code class="language-python">""
</code></pre></div>
                    </details>
                </td>
            </tr>
            
            <tr>
                <td class="status-FAIL">FAIL</td>
                <td>Coverage did not increase</td>
                <td>0</td>
                <td>python</td>
                <td>
                    <details>
                        <summary>View Full Code</summary>
                        <pre><code><span class="diff-unchanged">  import pytest</span>
<span class="diff-unchanged">  from app import Node, Dijkstra</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_simple_path():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 1:</span>
<span class="diff-unchanged">      A simple 3x3 grid with no obstacles. The start is at (0,0) and the goal is at (2,2).</span>
<span class="diff-unchanged">      We expect the planner to find a path.</span>
<span class="diff-unchanged">      Note: The returned path is in reverse order (goal to start).</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 0, 0],</span>
<span class="diff-unchanged">          [0, 0, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">      </span>
<span class="diff-unchanged">      assert found is True, "Path should be found in a clear grid."</span>
<span class="diff-unchanged">      # Check that the path starts at the goal and ends at the start.</span>
<span class="diff-unchanged">      assert path[0] == goal, "Path should start with the goal node."</span>
<span class="diff-unchanged">      assert path[-1] == start, "Path should end with the start node."</span>
<span class="diff-unchanged">      # Optionally, check that the length of the path is reasonable (at least Manhattan distance + 1)</span>
<span class="diff-unchanged">      manhattan_distance = abs(goal.x - start.x) + abs(goal.y - start.y)</span>
<span class="diff-unchanged">      assert len(path) >= manhattan_distance + 1</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_no_path():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 2:</span>
<span class="diff-unchanged">      A 3x3 grid where the start is completely blocked off.</span>
<span class="diff-unchanged">      Start is at (0,0) and obstacles are placed so that there is no valid move.</span>
<span class="diff-unchanged">      The planner should return that no path is found.</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [1, 1, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">      assert found is False, "No path should be found if the start is blocked."</span>
<span class="diff-unchanged">      assert path == [], "Path should be empty when no path is found."</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_obstacle_detour():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 3:</span>
<span class="diff-unchanged">      A 3x3 grid with a vertical obstacle in the middle.</span>
<span class="diff-unchanged">      The start is at (0,0) and the goal is at (2,2). A detour is required.</span>
<span class="diff-unchanged">      We expect the planner to find a valid path.</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">      assert found is True, "A path should be found around the obstacle."</span>
<span class="diff-unchanged">      assert path[0] == goal, "Path should start with the goal node."</span>
<span class="diff-unchanged">      assert path[-1] == start, "Path should end with the start node."</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_goal_not_found():</span>
<span class="diff-unchanged">      planner = Dijkstra([[0]])</span>
<span class="diff-unchanged">      closed_list = set()</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(1, 1, 0)</span>
<span class="diff-unchanged">      path = planner.convert_closed_list_to_path(closed_list, start, goal)</span>
<span class="diff-unchanged">      assert path == []</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_node_repr():</span>
<span class="diff-unchanged">      node = Node(1, 2, 3, 4, 5)</span>
<span class="diff-unchanged">      expected_repr = "Node(x=1, y=2, cost=3, id=4, pid=5)"</span>
<span class="diff-unchanged">      assert repr(node) == expected_repr</span>
<span class="diff-added">+ </span>
<span class="diff-added">+ </span>
<span class="diff-added">+ def test_goal_unreachable_row_obstacle():</span>
<span class="diff-added">+     n = 3</span>
<span class="diff-added">+     grid = [</span>
<span class="diff-added">+         [0, 0, 0],</span>
<span class="diff-added">+         [1, 1, 1],</span>
<span class="diff-added">+         [0, 0, 0]</span>
<span class="diff-added">+     ]</span>
<span class="diff-added">+     start = Node(0, 0, 0)</span>
<span class="diff-added">+     goal = Node(2, 2, 0)</span>
<span class="diff-added">+     start.id = start.x * n + start.y</span>
<span class="diff-added">+     start.pid = start.id</span>
<span class="diff-added">+     goal.id = goal.x * n + goal.y</span>
<span class="diff-added">+     grid[start.x][start.y] = 0</span>
<span class="diff-added">+     grid[goal.x][goal.y] = 0</span>
<span class="diff-added">+ </span>
<span class="diff-added">+     planner = Dijkstra(grid)</span>
<span class="diff-added">+     found, path = planner.plan(start, goal)</span>
<span class="diff-added">+ </span>
<span class="diff-added">+     assert found is False</span>
<span class="diff-added">+     assert path == []</span></code></pre>
                    </details>
                </td>
                <td>
                    <details>
                        <summary>View More</summary>
                        <div><strong>STDERR:</strong> <pre><code class="language-python"></code></pre></div>
                        <div><strong>STDOUT:</strong> <pre><code class="language-python">============================= test session starts ==============================
platform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0
rootdir: /home/thiuquan/code/maude/cover-agent/dijkstra
plugins: anyio-4.8.0, cov-6.0.0
collected 6 items

test_app.py ......                                                       [100%]

---------- coverage: platform linux, python 3.10.12-final-0 ----------
Name          Stmts   Miss Branch BrPart  Cover
-----------------------------------------------
app.py          106     17     32      3    86%
test_app.py      55      0      0      0   100%
-----------------------------------------------
TOTAL           161     17     32      3    90%
Coverage XML written to file coverage.xml


============================== 6 passed in 0.07s ===============================
</code></pre></div>
                        <div><strong>Test Code:</strong> <pre><code class="language-python">def test_goal_unreachable_row_obstacle():
    n = 3
    grid = [
        [0, 0, 0],
        [1, 1, 1],
        [0, 0, 0]
    ]
    start = Node(0, 0, 0)
    goal = Node(2, 2, 0)
    start.id = start.x * n + start.y
    start.pid = start.id
    goal.id = goal.x * n + goal.y
    grid[start.x][start.y] = 0
    grid[goal.x][goal.y] = 0

    planner = Dijkstra(grid)
    found, path = planner.plan(start, goal)

    assert found is False
    assert path == []
</code></pre></div>
                        <div><strong>Imports:</strong> <pre><code class="language-python">""
</code></pre></div>
                    </details>
                </td>
            </tr>
            
            <tr>
                <td class="status-FAIL">FAIL</td>
                <td>Coverage did not increase</td>
                <td>0</td>
                <td>python</td>
                <td>
                    <details>
                        <summary>View Full Code</summary>
                        <pre><code><span class="diff-unchanged">  import pytest</span>
<span class="diff-unchanged">  from app import Node, Dijkstra</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_simple_path():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 1:</span>
<span class="diff-unchanged">      A simple 3x3 grid with no obstacles. The start is at (0,0) and the goal is at (2,2).</span>
<span class="diff-unchanged">      We expect the planner to find a path.</span>
<span class="diff-unchanged">      Note: The returned path is in reverse order (goal to start).</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 0, 0],</span>
<span class="diff-unchanged">          [0, 0, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">      </span>
<span class="diff-unchanged">      assert found is True, "Path should be found in a clear grid."</span>
<span class="diff-unchanged">      # Check that the path starts at the goal and ends at the start.</span>
<span class="diff-unchanged">      assert path[0] == goal, "Path should start with the goal node."</span>
<span class="diff-unchanged">      assert path[-1] == start, "Path should end with the start node."</span>
<span class="diff-unchanged">      # Optionally, check that the length of the path is reasonable (at least Manhattan distance + 1)</span>
<span class="diff-unchanged">      manhattan_distance = abs(goal.x - start.x) + abs(goal.y - start.y)</span>
<span class="diff-unchanged">      assert len(path) >= manhattan_distance + 1</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_no_path():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 2:</span>
<span class="diff-unchanged">      A 3x3 grid where the start is completely blocked off.</span>
<span class="diff-unchanged">      Start is at (0,0) and obstacles are placed so that there is no valid move.</span>
<span class="diff-unchanged">      The planner should return that no path is found.</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [1, 1, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">      assert found is False, "No path should be found if the start is blocked."</span>
<span class="diff-unchanged">      assert path == [], "Path should be empty when no path is found."</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_obstacle_detour():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 3:</span>
<span class="diff-unchanged">      A 3x3 grid with a vertical obstacle in the middle.</span>
<span class="diff-unchanged">      The start is at (0,0) and the goal is at (2,2). A detour is required.</span>
<span class="diff-unchanged">      We expect the planner to find a valid path.</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">      assert found is True, "A path should be found around the obstacle."</span>
<span class="diff-unchanged">      assert path[0] == goal, "Path should start with the goal node."</span>
<span class="diff-unchanged">      assert path[-1] == start, "Path should end with the start node."</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_goal_not_found():</span>
<span class="diff-unchanged">      planner = Dijkstra([[0]])</span>
<span class="diff-unchanged">      closed_list = set()</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(1, 1, 0)</span>
<span class="diff-unchanged">      path = planner.convert_closed_list_to_path(closed_list, start, goal)</span>
<span class="diff-unchanged">      assert path == []</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_node_repr():</span>
<span class="diff-unchanged">      node = Node(1, 2, 3, 4, 5)</span>
<span class="diff-unchanged">      expected_repr = "Node(x=1, y=2, cost=3, id=4, pid=5)"</span>
<span class="diff-unchanged">      assert repr(node) == expected_repr</span>
<span class="diff-added">+ </span>
<span class="diff-added">+ </span>
<span class="diff-added">+ def test_convert_closed_list_goal_not_in_closed_list():</span>
<span class="diff-added">+     planner = Dijkstra([[0]])</span>
<span class="diff-added">+     closed_list = {Node(0, 0)}</span>
<span class="diff-added">+     start = Node(0, 0, 0)</span>
<span class="diff-added">+     goal = Node(0, 1, 0)</span>
<span class="diff-added">+     path = planner.convert_closed_list_to_path(closed_list, start, goal)</span>
<span class="diff-added">+     assert path == []</span></code></pre>
                    </details>
                </td>
                <td>
                    <details>
                        <summary>View More</summary>
                        <div><strong>STDERR:</strong> <pre><code class="language-python"></code></pre></div>
                        <div><strong>STDOUT:</strong> <pre><code class="language-python">============================= test session starts ==============================
platform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0
rootdir: /home/thiuquan/code/maude/cover-agent/dijkstra
plugins: anyio-4.8.0, cov-6.0.0
collected 6 items

test_app.py ......                                                       [100%]

---------- coverage: platform linux, python 3.10.12-final-0 ----------
Name          Stmts   Miss Branch BrPart  Cover
-----------------------------------------------
app.py          106     17     32      3    86%
test_app.py      48      0      0      0   100%
-----------------------------------------------
TOTAL           154     17     32      3    89%
Coverage XML written to file coverage.xml


============================== 6 passed in 0.10s ===============================
</code></pre></div>
                        <div><strong>Test Code:</strong> <pre><code class="language-python">def test_convert_closed_list_goal_not_in_closed_list():
    planner = Dijkstra([[0]])
    closed_list = {Node(0, 0)}
    start = Node(0, 0, 0)
    goal = Node(0, 1, 0)
    path = planner.convert_closed_list_to_path(closed_list, start, goal)
    assert path == []
</code></pre></div>
                        <div><strong>Imports:</strong> <pre><code class="language-python">""
</code></pre></div>
                    </details>
                </td>
            </tr>
            
            <tr>
                <td class="status-FAIL">FAIL</td>
                <td>Coverage did not increase</td>
                <td>0</td>
                <td>python</td>
                <td>
                    <details>
                        <summary>View Full Code</summary>
                        <pre><code><span class="diff-unchanged">  import pytest</span>
<span class="diff-unchanged">  from app import Node, Dijkstra</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_simple_path():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 1:</span>
<span class="diff-unchanged">      A simple 3x3 grid with no obstacles. The start is at (0,0) and the goal is at (2,2).</span>
<span class="diff-unchanged">      We expect the planner to find a path.</span>
<span class="diff-unchanged">      Note: The returned path is in reverse order (goal to start).</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 0, 0],</span>
<span class="diff-unchanged">          [0, 0, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">      </span>
<span class="diff-unchanged">      assert found is True, "Path should be found in a clear grid."</span>
<span class="diff-unchanged">      # Check that the path starts at the goal and ends at the start.</span>
<span class="diff-unchanged">      assert path[0] == goal, "Path should start with the goal node."</span>
<span class="diff-unchanged">      assert path[-1] == start, "Path should end with the start node."</span>
<span class="diff-unchanged">      # Optionally, check that the length of the path is reasonable (at least Manhattan distance + 1)</span>
<span class="diff-unchanged">      manhattan_distance = abs(goal.x - start.x) + abs(goal.y - start.y)</span>
<span class="diff-unchanged">      assert len(path) >= manhattan_distance + 1</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_no_path():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 2:</span>
<span class="diff-unchanged">      A 3x3 grid where the start is completely blocked off.</span>
<span class="diff-unchanged">      Start is at (0,0) and obstacles are placed so that there is no valid move.</span>
<span class="diff-unchanged">      The planner should return that no path is found.</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [1, 1, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">      assert found is False, "No path should be found if the start is blocked."</span>
<span class="diff-unchanged">      assert path == [], "Path should be empty when no path is found."</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_obstacle_detour():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 3:</span>
<span class="diff-unchanged">      A 3x3 grid with a vertical obstacle in the middle.</span>
<span class="diff-unchanged">      The start is at (0,0) and the goal is at (2,2). A detour is required.</span>
<span class="diff-unchanged">      We expect the planner to find a valid path.</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">      assert found is True, "A path should be found around the obstacle."</span>
<span class="diff-unchanged">      assert path[0] == goal, "Path should start with the goal node."</span>
<span class="diff-unchanged">      assert path[-1] == start, "Path should end with the start node."</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_goal_not_found():</span>
<span class="diff-unchanged">      planner = Dijkstra([[0]])</span>
<span class="diff-unchanged">      closed_list = set()</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(1, 1, 0)</span>
<span class="diff-unchanged">      path = planner.convert_closed_list_to_path(closed_list, start, goal)</span>
<span class="diff-unchanged">      assert path == []</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_node_repr():</span>
<span class="diff-unchanged">      node = Node(1, 2, 3, 4, 5)</span>
<span class="diff-unchanged">      expected_repr = "Node(x=1, y=2, cost=3, id=4, pid=5)"</span>
<span class="diff-unchanged">      assert repr(node) == expected_repr</span>
<span class="diff-added">+ </span>
<span class="diff-added">+ </span>
<span class="diff-added">+ def test_start_equals_goal():</span>
<span class="diff-added">+     grid = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]</span>
<span class="diff-added">+     start = Node(1, 1, 0)</span>
<span class="diff-added">+     goal = Node(1, 1, 0)</span>
<span class="diff-added">+     planner = Dijkstra(grid)</span>
<span class="diff-added">+     found, path = planner.plan(start, goal)</span>
<span class="diff-added">+     assert found is True</span>
<span class="diff-added">+     assert path[0] == goal</span>
<span class="diff-added">+     assert path[-1] == start</span></code></pre>
                    </details>
                </td>
                <td>
                    <details>
                        <summary>View More</summary>
                        <div><strong>STDERR:</strong> <pre><code class="language-python"></code></pre></div>
                        <div><strong>STDOUT:</strong> <pre><code class="language-python">============================= test session starts ==============================
platform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0
rootdir: /home/thiuquan/code/maude/cover-agent/dijkstra
plugins: anyio-4.8.0, cov-6.0.0
collected 6 items

test_app.py ......                                                       [100%]

---------- coverage: platform linux, python 3.10.12-final-0 ----------
Name          Stmts   Miss Branch BrPart  Cover
-----------------------------------------------
app.py          106     17     32      3    86%
test_app.py      50      0      0      0   100%
-----------------------------------------------
TOTAL           156     17     32      3    89%
Coverage XML written to file coverage.xml


============================== 6 passed in 0.09s ===============================
</code></pre></div>
                        <div><strong>Test Code:</strong> <pre><code class="language-python">def test_start_equals_goal():
    grid = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]
    start = Node(1, 1, 0)
    goal = Node(1, 1, 0)
    planner = Dijkstra(grid)
    found, path = planner.plan(start, goal)
    assert found is True
    assert path[0] == goal
    assert path[-1] == start
</code></pre></div>
                        <div><strong>Imports:</strong> <pre><code class="language-python">""
</code></pre></div>
                    </details>
                </td>
            </tr>
            
            <tr>
                <td class="status-FAIL">FAIL</td>
                <td>Test failed</td>
                <td>1</td>
                <td>python</td>
                <td>
                    <details>
                        <summary>View Full Code</summary>
                        <pre><code><span class="diff-unchanged">  import pytest</span>
<span class="diff-unchanged">  from app import Node, Dijkstra</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_simple_path():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 1:</span>
<span class="diff-unchanged">      A simple 3x3 grid with no obstacles. The start is at (0,0) and the goal is at (2,2).</span>
<span class="diff-unchanged">      We expect the planner to find a path.</span>
<span class="diff-unchanged">      Note: The returned path is in reverse order (goal to start).</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 0, 0],</span>
<span class="diff-unchanged">          [0, 0, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">      </span>
<span class="diff-unchanged">      assert found is True, "Path should be found in a clear grid."</span>
<span class="diff-unchanged">      # Check that the path starts at the goal and ends at the start.</span>
<span class="diff-unchanged">      assert path[0] == goal, "Path should start with the goal node."</span>
<span class="diff-unchanged">      assert path[-1] == start, "Path should end with the start node."</span>
<span class="diff-unchanged">      # Optionally, check that the length of the path is reasonable (at least Manhattan distance + 1)</span>
<span class="diff-unchanged">      manhattan_distance = abs(goal.x - start.x) + abs(goal.y - start.y)</span>
<span class="diff-unchanged">      assert len(path) >= manhattan_distance + 1</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_no_path():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 2:</span>
<span class="diff-unchanged">      A 3x3 grid where the start is completely blocked off.</span>
<span class="diff-unchanged">      Start is at (0,0) and obstacles are placed so that there is no valid move.</span>
<span class="diff-unchanged">      The planner should return that no path is found.</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [1, 1, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">      assert found is False, "No path should be found if the start is blocked."</span>
<span class="diff-unchanged">      assert path == [], "Path should be empty when no path is found."</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_obstacle_detour():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 3:</span>
<span class="diff-unchanged">      A 3x3 grid with a vertical obstacle in the middle.</span>
<span class="diff-unchanged">      The start is at (0,0) and the goal is at (2,2). A detour is required.</span>
<span class="diff-unchanged">      We expect the planner to find a valid path.</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">      assert found is True, "A path should be found around the obstacle."</span>
<span class="diff-unchanged">      assert path[0] == goal, "Path should start with the goal node."</span>
<span class="diff-unchanged">      assert path[-1] == start, "Path should end with the start node."</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_goal_not_found():</span>
<span class="diff-unchanged">      planner = Dijkstra([[0]])</span>
<span class="diff-unchanged">      closed_list = set()</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(1, 1, 0)</span>
<span class="diff-unchanged">      path = planner.convert_closed_list_to_path(closed_list, start, goal)</span>
<span class="diff-unchanged">      assert path == []</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_node_repr():</span>
<span class="diff-unchanged">      node = Node(1, 2, 3, 4, 5)</span>
<span class="diff-unchanged">      expected_repr = "Node(x=1, y=2, cost=3, id=4, pid=5)"</span>
<span class="diff-unchanged">      assert repr(node) == expected_repr</span>
<span class="diff-added">+ </span>
<span class="diff-added">+ </span>
<span class="diff-added">+ def test_convert_closed_list_parent_not_found():</span>
<span class="diff-added">+     planner = Dijkstra([[0, 0], [0, 0]])</span>
<span class="diff-added">+     closed_list = {Node(0, 0), Node(1, 0)}</span>
<span class="diff-added">+     start = Node(0, 0, 0)</span>
<span class="diff-added">+     goal = Node(1, 0, 0)</span>
<span class="diff-added">+     goal.pid = 5</span>
<span class="diff-added">+     path = planner.convert_closed_list_to_path(closed_list, start, goal)</span>
<span class="diff-added">+     assert path == []</span></code></pre>
                    </details>
                </td>
                <td>
                    <details>
                        <summary>View More</summary>
                        <div><strong>STDERR:</strong> <pre><code class="language-python"></code></pre></div>
                        <div><strong>STDOUT:</strong> <pre><code class="language-python">============================= test session starts ==============================
platform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0
rootdir: /home/thiuquan/code/maude/cover-agent/dijkstra
plugins: anyio-4.8.0, cov-6.0.0
collected 6 items

test_app.py .....F                                                       [100%]

=================================== FAILURES ===================================
__________________ test_convert_closed_list_parent_not_found ___________________

    def test_convert_closed_list_parent_not_found():
        planner = Dijkstra([[0, 0], [0, 0]])
        closed_list = {Node(0, 0), Node(1, 0)}
        start = Node(0, 0, 0)
        goal = Node(1, 0, 0)
        goal.pid = 5
>       path = planner.convert_closed_list_to_path(closed_list, start, goal)

test_app.py:92: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <app.Dijkstra object at 0x7f6192a39090>
closed_list = {Node(x=1, y=0, cost=0, id=None, pid=None), Node(x=0, y=0, cost=0, id=None, pid=None)}
start = Node(x=0, y=0, cost=0, id=None, pid=None)
goal = Node(x=1, y=0, cost=0, id=None, pid=5)

    def convert_closed_list_to_path(self, closed_list, start, goal):
        """
        Converts the closed list (visited nodes) into a path from goal to start.
        Backtracks from the goal node using the stored parent ids (pid).
        """
        current = None
        # Find the node in closed_list that matches the goal coordinates.
        for node in closed_list:
            if compare_coordinates(node, goal):
                current = node
                break
    
        if current is None:
            print("Error in calculating path")
            return []
    
        path = []
        # Backtrack until we reach the start.
        while not compare_coordinates(current, start):
            path.append(current)
>           parent_x = current.pid // self.n
E           TypeError: unsupported operand type(s) for //: 'NoneType' and 'int'

app.py:144: TypeError

---------- coverage: platform linux, python 3.10.12-final-0 ----------
Name          Stmts   Miss Branch BrPart  Cover
-----------------------------------------------
app.py          106     17     32      3    86%
test_app.py      49      1      0      0    98%
-----------------------------------------------
TOTAL           155     18     32      3    89%
Coverage XML written to file coverage.xml

=========================== short test summary info ============================
FAILED test_app.py::test_convert_closed_list_parent_not_found - TypeError: un...
========================= 1 failed, 5 passed in 0.12s ==========================
</code></pre></div>
                        <div><strong>Test Code:</strong> <pre><code class="language-python">def test_convert_closed_list_parent_not_found():
    planner = Dijkstra([[0, 0], [0, 0]])
    closed_list = {Node(0, 0), Node(1, 0)}
    start = Node(0, 0, 0)
    goal = Node(1, 0, 0)
    goal.pid = 5
    path = planner.convert_closed_list_to_path(closed_list, start, goal)
    assert path == []
</code></pre></div>
                        <div><strong>Imports:</strong> <pre><code class="language-python">""
</code></pre></div>
                    </details>
                </td>
            </tr>
            
            <tr>
                <td class="status-FAIL">FAIL</td>
                <td>Coverage did not increase</td>
                <td>0</td>
                <td>python</td>
                <td>
                    <details>
                        <summary>View Full Code</summary>
                        <pre><code><span class="diff-unchanged">  import pytest</span>
<span class="diff-unchanged">  from app import Node, Dijkstra</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_simple_path():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 1:</span>
<span class="diff-unchanged">      A simple 3x3 grid with no obstacles. The start is at (0,0) and the goal is at (2,2).</span>
<span class="diff-unchanged">      We expect the planner to find a path.</span>
<span class="diff-unchanged">      Note: The returned path is in reverse order (goal to start).</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 0, 0],</span>
<span class="diff-unchanged">          [0, 0, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">      </span>
<span class="diff-unchanged">      assert found is True, "Path should be found in a clear grid."</span>
<span class="diff-unchanged">      # Check that the path starts at the goal and ends at the start.</span>
<span class="diff-unchanged">      assert path[0] == goal, "Path should start with the goal node."</span>
<span class="diff-unchanged">      assert path[-1] == start, "Path should end with the start node."</span>
<span class="diff-unchanged">      # Optionally, check that the length of the path is reasonable (at least Manhattan distance + 1)</span>
<span class="diff-unchanged">      manhattan_distance = abs(goal.x - start.x) + abs(goal.y - start.y)</span>
<span class="diff-unchanged">      assert len(path) >= manhattan_distance + 1</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_no_path():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 2:</span>
<span class="diff-unchanged">      A 3x3 grid where the start is completely blocked off.</span>
<span class="diff-unchanged">      Start is at (0,0) and obstacles are placed so that there is no valid move.</span>
<span class="diff-unchanged">      The planner should return that no path is found.</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [1, 1, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">      assert found is False, "No path should be found if the start is blocked."</span>
<span class="diff-unchanged">      assert path == [], "Path should be empty when no path is found."</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_obstacle_detour():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 3:</span>
<span class="diff-unchanged">      A 3x3 grid with a vertical obstacle in the middle.</span>
<span class="diff-unchanged">      The start is at (0,0) and the goal is at (2,2). A detour is required.</span>
<span class="diff-unchanged">      We expect the planner to find a valid path.</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">      assert found is True, "A path should be found around the obstacle."</span>
<span class="diff-unchanged">      assert path[0] == goal, "Path should start with the goal node."</span>
<span class="diff-unchanged">      assert path[-1] == start, "Path should end with the start node."</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_goal_not_found():</span>
<span class="diff-unchanged">      planner = Dijkstra([[0]])</span>
<span class="diff-unchanged">      closed_list = set()</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(1, 1, 0)</span>
<span class="diff-unchanged">      path = planner.convert_closed_list_to_path(closed_list, start, goal)</span>
<span class="diff-unchanged">      assert path == []</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_node_repr():</span>
<span class="diff-unchanged">      node = Node(1, 2, 3, 4, 5)</span>
<span class="diff-unchanged">      expected_repr = "Node(x=1, y=2, cost=3, id=4, pid=5)"</span>
<span class="diff-unchanged">      assert repr(node) == expected_repr</span>
<span class="diff-added">+ </span>
<span class="diff-added">+ </span>
<span class="diff-added">+ def test_goal_unreachable_row_obstacle():</span>
<span class="diff-added">+     n = 3</span>
<span class="diff-added">+     grid = [</span>
<span class="diff-added">+         [0, 0, 0],</span>
<span class="diff-added">+         [1, 1, 1],</span>
<span class="diff-added">+         [0, 0, 0]</span>
<span class="diff-added">+     ]</span>
<span class="diff-added">+     start = Node(0, 0, 0)</span>
<span class="diff-added">+     goal = Node(2, 2, 0)</span>
<span class="diff-added">+     start.id = start.x * n + start.y</span>
<span class="diff-added">+     start.pid = start.id</span>
<span class="diff-added">+     goal.id = goal.x * n + goal.y</span>
<span class="diff-added">+     grid[start.x][start.y] = 0</span>
<span class="diff-added">+     grid[goal.x][goal.y] = 0</span>
<span class="diff-added">+ </span>
<span class="diff-added">+     planner = Dijkstra(grid)</span>
<span class="diff-added">+     found, path = planner.plan(start, goal)</span>
<span class="diff-added">+ </span>
<span class="diff-added">+     assert found is False</span>
<span class="diff-added">+     assert path == []</span></code></pre>
                    </details>
                </td>
                <td>
                    <details>
                        <summary>View More</summary>
                        <div><strong>STDERR:</strong> <pre><code class="language-python"></code></pre></div>
                        <div><strong>STDOUT:</strong> <pre><code class="language-python">============================= test session starts ==============================
platform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0
rootdir: /home/thiuquan/code/maude/cover-agent/dijkstra
plugins: anyio-4.8.0, cov-6.0.0
collected 6 items

test_app.py ......                                                       [100%]

---------- coverage: platform linux, python 3.10.12-final-0 ----------
Name          Stmts   Miss Branch BrPart  Cover
-----------------------------------------------
app.py          106     17     32      3    86%
test_app.py      55      0      0      0   100%
-----------------------------------------------
TOTAL           161     17     32      3    90%
Coverage XML written to file coverage.xml


============================== 6 passed in 0.07s ===============================
</code></pre></div>
                        <div><strong>Test Code:</strong> <pre><code class="language-python">def test_goal_unreachable_row_obstacle():
    n = 3
    grid = [
        [0, 0, 0],
        [1, 1, 1],
        [0, 0, 0]
    ]
    start = Node(0, 0, 0)
    goal = Node(2, 2, 0)
    start.id = start.x * n + start.y
    start.pid = start.id
    goal.id = goal.x * n + goal.y
    grid[start.x][start.y] = 0
    grid[goal.x][goal.y] = 0

    planner = Dijkstra(grid)
    found, path = planner.plan(start, goal)

    assert found is False
    assert path == []
</code></pre></div>
                        <div><strong>Imports:</strong> <pre><code class="language-python">""
</code></pre></div>
                    </details>
                </td>
            </tr>
            
            <tr>
                <td class="status-FAIL">FAIL</td>
                <td>Coverage did not increase</td>
                <td>0</td>
                <td>python</td>
                <td>
                    <details>
                        <summary>View Full Code</summary>
                        <pre><code><span class="diff-unchanged">  import pytest</span>
<span class="diff-unchanged">  from app import Node, Dijkstra</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_simple_path():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 1:</span>
<span class="diff-unchanged">      A simple 3x3 grid with no obstacles. The start is at (0,0) and the goal is at (2,2).</span>
<span class="diff-unchanged">      We expect the planner to find a path.</span>
<span class="diff-unchanged">      Note: The returned path is in reverse order (goal to start).</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 0, 0],</span>
<span class="diff-unchanged">          [0, 0, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">      </span>
<span class="diff-unchanged">      assert found is True, "Path should be found in a clear grid."</span>
<span class="diff-unchanged">      # Check that the path starts at the goal and ends at the start.</span>
<span class="diff-unchanged">      assert path[0] == goal, "Path should start with the goal node."</span>
<span class="diff-unchanged">      assert path[-1] == start, "Path should end with the start node."</span>
<span class="diff-unchanged">      # Optionally, check that the length of the path is reasonable (at least Manhattan distance + 1)</span>
<span class="diff-unchanged">      manhattan_distance = abs(goal.x - start.x) + abs(goal.y - start.y)</span>
<span class="diff-unchanged">      assert len(path) >= manhattan_distance + 1</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_no_path():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 2:</span>
<span class="diff-unchanged">      A 3x3 grid where the start is completely blocked off.</span>
<span class="diff-unchanged">      Start is at (0,0) and obstacles are placed so that there is no valid move.</span>
<span class="diff-unchanged">      The planner should return that no path is found.</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [1, 1, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">      assert found is False, "No path should be found if the start is blocked."</span>
<span class="diff-unchanged">      assert path == [], "Path should be empty when no path is found."</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_obstacle_detour():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 3:</span>
<span class="diff-unchanged">      A 3x3 grid with a vertical obstacle in the middle.</span>
<span class="diff-unchanged">      The start is at (0,0) and the goal is at (2,2). A detour is required.</span>
<span class="diff-unchanged">      We expect the planner to find a valid path.</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">      assert found is True, "A path should be found around the obstacle."</span>
<span class="diff-unchanged">      assert path[0] == goal, "Path should start with the goal node."</span>
<span class="diff-unchanged">      assert path[-1] == start, "Path should end with the start node."</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_goal_not_found():</span>
<span class="diff-unchanged">      planner = Dijkstra([[0]])</span>
<span class="diff-unchanged">      closed_list = set()</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(1, 1, 0)</span>
<span class="diff-unchanged">      path = planner.convert_closed_list_to_path(closed_list, start, goal)</span>
<span class="diff-unchanged">      assert path == []</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_node_repr():</span>
<span class="diff-unchanged">      node = Node(1, 2, 3, 4, 5)</span>
<span class="diff-unchanged">      expected_repr = "Node(x=1, y=2, cost=3, id=4, pid=5)"</span>
<span class="diff-unchanged">      assert repr(node) == expected_repr</span>
<span class="diff-added">+ </span>
<span class="diff-added">+ </span>
<span class="diff-added">+ def test_start_equals_goal():</span>
<span class="diff-added">+     grid = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]</span>
<span class="diff-added">+     start = Node(1, 1, 0)</span>
<span class="diff-added">+     goal = Node(1, 1, 0)</span>
<span class="diff-added">+     planner = Dijkstra(grid)</span>
<span class="diff-added">+     found, path = planner.plan(start, goal)</span>
<span class="diff-added">+     assert found is True</span>
<span class="diff-added">+     assert path[0] == goal</span>
<span class="diff-added">+     assert path[-1] == start</span></code></pre>
                    </details>
                </td>
                <td>
                    <details>
                        <summary>View More</summary>
                        <div><strong>STDERR:</strong> <pre><code class="language-python"></code></pre></div>
                        <div><strong>STDOUT:</strong> <pre><code class="language-python">============================= test session starts ==============================
platform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0
rootdir: /home/thiuquan/code/maude/cover-agent/dijkstra
plugins: anyio-4.8.0, cov-6.0.0
collected 6 items

test_app.py ......                                                       [100%]

---------- coverage: platform linux, python 3.10.12-final-0 ----------
Name          Stmts   Miss Branch BrPart  Cover
-----------------------------------------------
app.py          106     17     32      3    86%
test_app.py      50      0      0      0   100%
-----------------------------------------------
TOTAL           156     17     32      3    89%
Coverage XML written to file coverage.xml


============================== 6 passed in 0.08s ===============================
</code></pre></div>
                        <div><strong>Test Code:</strong> <pre><code class="language-python">def test_start_equals_goal():
    grid = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]
    start = Node(1, 1, 0)
    goal = Node(1, 1, 0)
    planner = Dijkstra(grid)
    found, path = planner.plan(start, goal)
    assert found is True
    assert path[0] == goal
    assert path[-1] == start
</code></pre></div>
                        <div><strong>Imports:</strong> <pre><code class="language-python">""
</code></pre></div>
                    </details>
                </td>
            </tr>
            
            <tr>
                <td class="status-FAIL">FAIL</td>
                <td>Coverage did not increase</td>
                <td>0</td>
                <td>python</td>
                <td>
                    <details>
                        <summary>View Full Code</summary>
                        <pre><code><span class="diff-unchanged">  import pytest</span>
<span class="diff-unchanged">  from app import Node, Dijkstra</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_simple_path():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 1:</span>
<span class="diff-unchanged">      A simple 3x3 grid with no obstacles. The start is at (0,0) and the goal is at (2,2).</span>
<span class="diff-unchanged">      We expect the planner to find a path.</span>
<span class="diff-unchanged">      Note: The returned path is in reverse order (goal to start).</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 0, 0],</span>
<span class="diff-unchanged">          [0, 0, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">      </span>
<span class="diff-unchanged">      assert found is True, "Path should be found in a clear grid."</span>
<span class="diff-unchanged">      # Check that the path starts at the goal and ends at the start.</span>
<span class="diff-unchanged">      assert path[0] == goal, "Path should start with the goal node."</span>
<span class="diff-unchanged">      assert path[-1] == start, "Path should end with the start node."</span>
<span class="diff-unchanged">      # Optionally, check that the length of the path is reasonable (at least Manhattan distance + 1)</span>
<span class="diff-unchanged">      manhattan_distance = abs(goal.x - start.x) + abs(goal.y - start.y)</span>
<span class="diff-unchanged">      assert len(path) >= manhattan_distance + 1</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_no_path():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 2:</span>
<span class="diff-unchanged">      A 3x3 grid where the start is completely blocked off.</span>
<span class="diff-unchanged">      Start is at (0,0) and obstacles are placed so that there is no valid move.</span>
<span class="diff-unchanged">      The planner should return that no path is found.</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [1, 1, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">      assert found is False, "No path should be found if the start is blocked."</span>
<span class="diff-unchanged">      assert path == [], "Path should be empty when no path is found."</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_obstacle_detour():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 3:</span>
<span class="diff-unchanged">      A 3x3 grid with a vertical obstacle in the middle.</span>
<span class="diff-unchanged">      The start is at (0,0) and the goal is at (2,2). A detour is required.</span>
<span class="diff-unchanged">      We expect the planner to find a valid path.</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">      assert found is True, "A path should be found around the obstacle."</span>
<span class="diff-unchanged">      assert path[0] == goal, "Path should start with the goal node."</span>
<span class="diff-unchanged">      assert path[-1] == start, "Path should end with the start node."</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_goal_not_found():</span>
<span class="diff-unchanged">      planner = Dijkstra([[0]])</span>
<span class="diff-unchanged">      closed_list = set()</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(1, 1, 0)</span>
<span class="diff-unchanged">      path = planner.convert_closed_list_to_path(closed_list, start, goal)</span>
<span class="diff-unchanged">      assert path == []</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_node_repr():</span>
<span class="diff-unchanged">      node = Node(1, 2, 3, 4, 5)</span>
<span class="diff-unchanged">      expected_repr = "Node(x=1, y=2, cost=3, id=4, pid=5)"</span>
<span class="diff-unchanged">      assert repr(node) == expected_repr</span>
<span class="diff-added">+ </span>
<span class="diff-added">+ </span>
<span class="diff-added">+ def test_convert_closed_list_goal_not_in_closed_list():</span>
<span class="diff-added">+     planner = Dijkstra([[0]])</span>
<span class="diff-added">+     closed_list = {Node(0, 0)}</span>
<span class="diff-added">+     start = Node(0, 0, 0)</span>
<span class="diff-added">+     goal = Node(0, 1, 0)</span>
<span class="diff-added">+     path = planner.convert_closed_list_to_path(closed_list, start, goal)</span>
<span class="diff-added">+     assert path == []</span></code></pre>
                    </details>
                </td>
                <td>
                    <details>
                        <summary>View More</summary>
                        <div><strong>STDERR:</strong> <pre><code class="language-python"></code></pre></div>
                        <div><strong>STDOUT:</strong> <pre><code class="language-python">============================= test session starts ==============================
platform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0
rootdir: /home/thiuquan/code/maude/cover-agent/dijkstra
plugins: anyio-4.8.0, cov-6.0.0
collected 6 items

test_app.py ......                                                       [100%]

---------- coverage: platform linux, python 3.10.12-final-0 ----------
Name          Stmts   Miss Branch BrPart  Cover
-----------------------------------------------
app.py          106     17     32      3    86%
test_app.py      48      0      0      0   100%
-----------------------------------------------
TOTAL           154     17     32      3    89%
Coverage XML written to file coverage.xml


============================== 6 passed in 0.08s ===============================
</code></pre></div>
                        <div><strong>Test Code:</strong> <pre><code class="language-python">def test_convert_closed_list_goal_not_in_closed_list():
    planner = Dijkstra([[0]])
    closed_list = {Node(0, 0)}
    start = Node(0, 0, 0)
    goal = Node(0, 1, 0)
    path = planner.convert_closed_list_to_path(closed_list, start, goal)
    assert path == []
</code></pre></div>
                        <div><strong>Imports:</strong> <pre><code class="language-python">""
</code></pre></div>
                    </details>
                </td>
            </tr>
            
            <tr>
                <td class="status-FAIL">FAIL</td>
                <td>Test failed</td>
                <td>1</td>
                <td>python</td>
                <td>
                    <details>
                        <summary>View Full Code</summary>
                        <pre><code><span class="diff-unchanged">  import pytest</span>
<span class="diff-unchanged">  from app import Node, Dijkstra</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_simple_path():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 1:</span>
<span class="diff-unchanged">      A simple 3x3 grid with no obstacles. The start is at (0,0) and the goal is at (2,2).</span>
<span class="diff-unchanged">      We expect the planner to find a path.</span>
<span class="diff-unchanged">      Note: The returned path is in reverse order (goal to start).</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 0, 0],</span>
<span class="diff-unchanged">          [0, 0, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">      </span>
<span class="diff-unchanged">      assert found is True, "Path should be found in a clear grid."</span>
<span class="diff-unchanged">      # Check that the path starts at the goal and ends at the start.</span>
<span class="diff-unchanged">      assert path[0] == goal, "Path should start with the goal node."</span>
<span class="diff-unchanged">      assert path[-1] == start, "Path should end with the start node."</span>
<span class="diff-unchanged">      # Optionally, check that the length of the path is reasonable (at least Manhattan distance + 1)</span>
<span class="diff-unchanged">      manhattan_distance = abs(goal.x - start.x) + abs(goal.y - start.y)</span>
<span class="diff-unchanged">      assert len(path) >= manhattan_distance + 1</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_no_path():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 2:</span>
<span class="diff-unchanged">      A 3x3 grid where the start is completely blocked off.</span>
<span class="diff-unchanged">      Start is at (0,0) and obstacles are placed so that there is no valid move.</span>
<span class="diff-unchanged">      The planner should return that no path is found.</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [1, 1, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">      assert found is False, "No path should be found if the start is blocked."</span>
<span class="diff-unchanged">      assert path == [], "Path should be empty when no path is found."</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_obstacle_detour():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 3:</span>
<span class="diff-unchanged">      A 3x3 grid with a vertical obstacle in the middle.</span>
<span class="diff-unchanged">      The start is at (0,0) and the goal is at (2,2). A detour is required.</span>
<span class="diff-unchanged">      We expect the planner to find a valid path.</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">      assert found is True, "A path should be found around the obstacle."</span>
<span class="diff-unchanged">      assert path[0] == goal, "Path should start with the goal node."</span>
<span class="diff-unchanged">      assert path[-1] == start, "Path should end with the start node."</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_goal_not_found():</span>
<span class="diff-unchanged">      planner = Dijkstra([[0]])</span>
<span class="diff-unchanged">      closed_list = set()</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(1, 1, 0)</span>
<span class="diff-unchanged">      path = planner.convert_closed_list_to_path(closed_list, start, goal)</span>
<span class="diff-unchanged">      assert path == []</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_node_repr():</span>
<span class="diff-unchanged">      node = Node(1, 2, 3, 4, 5)</span>
<span class="diff-unchanged">      expected_repr = "Node(x=1, y=2, cost=3, id=4, pid=5)"</span>
<span class="diff-unchanged">      assert repr(node) == expected_repr</span>
<span class="diff-added">+ </span>
<span class="diff-added">+ </span>
<span class="diff-added">+ def test_convert_closed_list_parent_not_found():</span>
<span class="diff-added">+     planner = Dijkstra([[0, 0], [0, 0]])</span>
<span class="diff-added">+     closed_list = {Node(0, 0), Node(1, 0)}</span>
<span class="diff-added">+     start = Node(0, 0, 0)</span>
<span class="diff-added">+     goal = Node(1, 0, 0)</span>
<span class="diff-added">+     goal.pid = 0</span>
<span class="diff-added">+     path = planner.convert_closed_list_to_path(closed_list, start, goal)</span>
<span class="diff-added">+     assert path == []</span></code></pre>
                    </details>
                </td>
                <td>
                    <details>
                        <summary>View More</summary>
                        <div><strong>STDERR:</strong> <pre><code class="language-python"></code></pre></div>
                        <div><strong>STDOUT:</strong> <pre><code class="language-python">============================= test session starts ==============================
platform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0
rootdir: /home/thiuquan/code/maude/cover-agent/dijkstra
plugins: anyio-4.8.0, cov-6.0.0
collected 6 items

test_app.py .....F                                                       [100%]

=================================== FAILURES ===================================
__________________ test_convert_closed_list_parent_not_found ___________________

    def test_convert_closed_list_parent_not_found():
        planner = Dijkstra([[0, 0], [0, 0]])
        closed_list = {Node(0, 0), Node(1, 0)}
        start = Node(0, 0, 0)
        goal = Node(1, 0, 0)
        goal.pid = 0
>       path = planner.convert_closed_list_to_path(closed_list, start, goal)

test_app.py:92: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <app.Dijkstra object at 0x7f058ff88fa0>
closed_list = {Node(x=1, y=0, cost=0, id=None, pid=None), Node(x=0, y=0, cost=0, id=None, pid=None)}
start = Node(x=0, y=0, cost=0, id=None, pid=None)
goal = Node(x=1, y=0, cost=0, id=None, pid=0)

    def convert_closed_list_to_path(self, closed_list, start, goal):
        """
        Converts the closed list (visited nodes) into a path from goal to start.
        Backtracks from the goal node using the stored parent ids (pid).
        """
        current = None
        # Find the node in closed_list that matches the goal coordinates.
        for node in closed_list:
            if compare_coordinates(node, goal):
                current = node
                break
    
        if current is None:
            print("Error in calculating path")
            return []
    
        path = []
        # Backtrack until we reach the start.
        while not compare_coordinates(current, start):
            path.append(current)
>           parent_x = current.pid // self.n
E           TypeError: unsupported operand type(s) for //: 'NoneType' and 'int'

app.py:144: TypeError

---------- coverage: platform linux, python 3.10.12-final-0 ----------
Name          Stmts   Miss Branch BrPart  Cover
-----------------------------------------------
app.py          106     17     32      3    86%
test_app.py      49      1      0      0    98%
-----------------------------------------------
TOTAL           155     18     32      3    89%
Coverage XML written to file coverage.xml

=========================== short test summary info ============================
FAILED test_app.py::test_convert_closed_list_parent_not_found - TypeError: un...
========================= 1 failed, 5 passed in 0.07s ==========================
</code></pre></div>
                        <div><strong>Test Code:</strong> <pre><code class="language-python">def test_convert_closed_list_parent_not_found():
    planner = Dijkstra([[0, 0], [0, 0]])
    closed_list = {Node(0, 0), Node(1, 0)}
    start = Node(0, 0, 0)
    goal = Node(1, 0, 0)
    goal.pid = 0
    path = planner.convert_closed_list_to_path(closed_list, start, goal)
    assert path == []
</code></pre></div>
                        <div><strong>Imports:</strong> <pre><code class="language-python">""
</code></pre></div>
                    </details>
                </td>
            </tr>
            
            <tr>
                <td class="status-FAIL">FAIL</td>
                <td>Coverage did not increase</td>
                <td>0</td>
                <td>python</td>
                <td>
                    <details>
                        <summary>View Full Code</summary>
                        <pre><code><span class="diff-unchanged">  import pytest</span>
<span class="diff-unchanged">  from app import Node, Dijkstra</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_simple_path():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 1:</span>
<span class="diff-unchanged">      A simple 3x3 grid with no obstacles. The start is at (0,0) and the goal is at (2,2).</span>
<span class="diff-unchanged">      We expect the planner to find a path.</span>
<span class="diff-unchanged">      Note: The returned path is in reverse order (goal to start).</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 0, 0],</span>
<span class="diff-unchanged">          [0, 0, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">      </span>
<span class="diff-unchanged">      assert found is True, "Path should be found in a clear grid."</span>
<span class="diff-unchanged">      # Check that the path starts at the goal and ends at the start.</span>
<span class="diff-unchanged">      assert path[0] == goal, "Path should start with the goal node."</span>
<span class="diff-unchanged">      assert path[-1] == start, "Path should end with the start node."</span>
<span class="diff-unchanged">      # Optionally, check that the length of the path is reasonable (at least Manhattan distance + 1)</span>
<span class="diff-unchanged">      manhattan_distance = abs(goal.x - start.x) + abs(goal.y - start.y)</span>
<span class="diff-unchanged">      assert len(path) >= manhattan_distance + 1</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_no_path():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 2:</span>
<span class="diff-unchanged">      A 3x3 grid where the start is completely blocked off.</span>
<span class="diff-unchanged">      Start is at (0,0) and obstacles are placed so that there is no valid move.</span>
<span class="diff-unchanged">      The planner should return that no path is found.</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [1, 1, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">      assert found is False, "No path should be found if the start is blocked."</span>
<span class="diff-unchanged">      assert path == [], "Path should be empty when no path is found."</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_obstacle_detour():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 3:</span>
<span class="diff-unchanged">      A 3x3 grid with a vertical obstacle in the middle.</span>
<span class="diff-unchanged">      The start is at (0,0) and the goal is at (2,2). A detour is required.</span>
<span class="diff-unchanged">      We expect the planner to find a valid path.</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">      assert found is True, "A path should be found around the obstacle."</span>
<span class="diff-unchanged">      assert path[0] == goal, "Path should start with the goal node."</span>
<span class="diff-unchanged">      assert path[-1] == start, "Path should end with the start node."</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_goal_not_found():</span>
<span class="diff-unchanged">      planner = Dijkstra([[0]])</span>
<span class="diff-unchanged">      closed_list = set()</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(1, 1, 0)</span>
<span class="diff-unchanged">      path = planner.convert_closed_list_to_path(closed_list, start, goal)</span>
<span class="diff-unchanged">      assert path == []</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_node_repr():</span>
<span class="diff-unchanged">      node = Node(1, 2, 3, 4, 5)</span>
<span class="diff-unchanged">      expected_repr = "Node(x=1, y=2, cost=3, id=4, pid=5)"</span>
<span class="diff-unchanged">      assert repr(node) == expected_repr</span>
<span class="diff-added">+ </span>
<span class="diff-added">+ </span>
<span class="diff-added">+ def test_start_equals_goal():</span>
<span class="diff-added">+     grid = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]</span>
<span class="diff-added">+     start = Node(1, 1, 0)</span>
<span class="diff-added">+     goal = Node(1, 1, 0)</span>
<span class="diff-added">+     planner = Dijkstra(grid)</span>
<span class="diff-added">+     found, path = planner.plan(start, goal)</span>
<span class="diff-added">+     assert found is True</span>
<span class="diff-added">+     assert path[0] == goal</span>
<span class="diff-added">+     assert path[-1] == start</span></code></pre>
                    </details>
                </td>
                <td>
                    <details>
                        <summary>View More</summary>
                        <div><strong>STDERR:</strong> <pre><code class="language-python"></code></pre></div>
                        <div><strong>STDOUT:</strong> <pre><code class="language-python">============================= test session starts ==============================
platform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0
rootdir: /home/thiuquan/code/maude/cover-agent/dijkstra
plugins: anyio-4.8.0, cov-6.0.0
collected 6 items

test_app.py ......                                                       [100%]

---------- coverage: platform linux, python 3.10.12-final-0 ----------
Name          Stmts   Miss Branch BrPart  Cover
-----------------------------------------------
app.py          106     17     32      3    86%
test_app.py      50      0      0      0   100%
-----------------------------------------------
TOTAL           156     17     32      3    89%
Coverage XML written to file coverage.xml


============================== 6 passed in 0.07s ===============================
</code></pre></div>
                        <div><strong>Test Code:</strong> <pre><code class="language-python">def test_start_equals_goal():
    grid = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]
    start = Node(1, 1, 0)
    goal = Node(1, 1, 0)
    planner = Dijkstra(grid)
    found, path = planner.plan(start, goal)
    assert found is True
    assert path[0] == goal
    assert path[-1] == start
</code></pre></div>
                        <div><strong>Imports:</strong> <pre><code class="language-python">""
</code></pre></div>
                    </details>
                </td>
            </tr>
            
            <tr>
                <td class="status-FAIL">FAIL</td>
                <td>Coverage did not increase</td>
                <td>0</td>
                <td>python</td>
                <td>
                    <details>
                        <summary>View Full Code</summary>
                        <pre><code><span class="diff-unchanged">  import pytest</span>
<span class="diff-unchanged">  from app import Node, Dijkstra</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_simple_path():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 1:</span>
<span class="diff-unchanged">      A simple 3x3 grid with no obstacles. The start is at (0,0) and the goal is at (2,2).</span>
<span class="diff-unchanged">      We expect the planner to find a path.</span>
<span class="diff-unchanged">      Note: The returned path is in reverse order (goal to start).</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 0, 0],</span>
<span class="diff-unchanged">          [0, 0, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">      </span>
<span class="diff-unchanged">      assert found is True, "Path should be found in a clear grid."</span>
<span class="diff-unchanged">      # Check that the path starts at the goal and ends at the start.</span>
<span class="diff-unchanged">      assert path[0] == goal, "Path should start with the goal node."</span>
<span class="diff-unchanged">      assert path[-1] == start, "Path should end with the start node."</span>
<span class="diff-unchanged">      # Optionally, check that the length of the path is reasonable (at least Manhattan distance + 1)</span>
<span class="diff-unchanged">      manhattan_distance = abs(goal.x - start.x) + abs(goal.y - start.y)</span>
<span class="diff-unchanged">      assert len(path) >= manhattan_distance + 1</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_no_path():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 2:</span>
<span class="diff-unchanged">      A 3x3 grid where the start is completely blocked off.</span>
<span class="diff-unchanged">      Start is at (0,0) and obstacles are placed so that there is no valid move.</span>
<span class="diff-unchanged">      The planner should return that no path is found.</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [1, 1, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">      assert found is False, "No path should be found if the start is blocked."</span>
<span class="diff-unchanged">      assert path == [], "Path should be empty when no path is found."</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_obstacle_detour():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 3:</span>
<span class="diff-unchanged">      A 3x3 grid with a vertical obstacle in the middle.</span>
<span class="diff-unchanged">      The start is at (0,0) and the goal is at (2,2). A detour is required.</span>
<span class="diff-unchanged">      We expect the planner to find a valid path.</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">      assert found is True, "A path should be found around the obstacle."</span>
<span class="diff-unchanged">      assert path[0] == goal, "Path should start with the goal node."</span>
<span class="diff-unchanged">      assert path[-1] == start, "Path should end with the start node."</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_goal_not_found():</span>
<span class="diff-unchanged">      planner = Dijkstra([[0]])</span>
<span class="diff-unchanged">      closed_list = set()</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(1, 1, 0)</span>
<span class="diff-unchanged">      path = planner.convert_closed_list_to_path(closed_list, start, goal)</span>
<span class="diff-unchanged">      assert path == []</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_node_repr():</span>
<span class="diff-unchanged">      node = Node(1, 2, 3, 4, 5)</span>
<span class="diff-unchanged">      expected_repr = "Node(x=1, y=2, cost=3, id=4, pid=5)"</span>
<span class="diff-unchanged">      assert repr(node) == expected_repr</span>
<span class="diff-added">+ </span>
<span class="diff-added">+ </span>
<span class="diff-added">+ def test_goal_unreachable_row_obstacle():</span>
<span class="diff-added">+     n = 3</span>
<span class="diff-added">+     grid = [</span>
<span class="diff-added">+         [0, 0, 0],</span>
<span class="diff-added">+         [1, 1, 1],</span>
<span class="diff-added">+         [0, 0, 0]</span>
<span class="diff-added">+     ]</span>
<span class="diff-added">+     start = Node(0, 0, 0)</span>
<span class="diff-added">+     goal = Node(2, 2, 0)</span>
<span class="diff-added">+     start.id = start.x * n + start.y</span>
<span class="diff-added">+     start.pid = start.id</span>
<span class="diff-added">+     goal.id = goal.x * n + goal.y</span>
<span class="diff-added">+     grid[start.x][start.y] = 0</span>
<span class="diff-added">+     grid[goal.x][goal.y] = 0</span>
<span class="diff-added">+ </span>
<span class="diff-added">+     planner = Dijkstra(grid)</span>
<span class="diff-added">+     found, path = planner.plan(start, goal)</span>
<span class="diff-added">+ </span>
<span class="diff-added">+     assert found is False</span>
<span class="diff-added">+     assert path == []</span></code></pre>
                    </details>
                </td>
                <td>
                    <details>
                        <summary>View More</summary>
                        <div><strong>STDERR:</strong> <pre><code class="language-python"></code></pre></div>
                        <div><strong>STDOUT:</strong> <pre><code class="language-python">============================= test session starts ==============================
platform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0
rootdir: /home/thiuquan/code/maude/cover-agent/dijkstra
plugins: anyio-4.8.0, cov-6.0.0
collected 6 items

test_app.py ......                                                       [100%]

---------- coverage: platform linux, python 3.10.12-final-0 ----------
Name          Stmts   Miss Branch BrPart  Cover
-----------------------------------------------
app.py          106     17     32      3    86%
test_app.py      55      0      0      0   100%
-----------------------------------------------
TOTAL           161     17     32      3    90%
Coverage XML written to file coverage.xml


============================== 6 passed in 0.07s ===============================
</code></pre></div>
                        <div><strong>Test Code:</strong> <pre><code class="language-python">def test_goal_unreachable_row_obstacle():
    n = 3
    grid = [
        [0, 0, 0],
        [1, 1, 1],
        [0, 0, 0]
    ]
    start = Node(0, 0, 0)
    goal = Node(2, 2, 0)
    start.id = start.x * n + start.y
    start.pid = start.id
    goal.id = goal.x * n + goal.y
    grid[start.x][start.y] = 0
    grid[goal.x][goal.y] = 0

    planner = Dijkstra(grid)
    found, path = planner.plan(start, goal)

    assert found is False
    assert path == []
</code></pre></div>
                        <div><strong>Imports:</strong> <pre><code class="language-python">""
</code></pre></div>
                    </details>
                </td>
            </tr>
            
            <tr>
                <td class="status-FAIL">FAIL</td>
                <td>Coverage did not increase</td>
                <td>0</td>
                <td>python</td>
                <td>
                    <details>
                        <summary>View Full Code</summary>
                        <pre><code><span class="diff-unchanged">  import pytest</span>
<span class="diff-unchanged">  from app import Node, Dijkstra</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_simple_path():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 1:</span>
<span class="diff-unchanged">      A simple 3x3 grid with no obstacles. The start is at (0,0) and the goal is at (2,2).</span>
<span class="diff-unchanged">      We expect the planner to find a path.</span>
<span class="diff-unchanged">      Note: The returned path is in reverse order (goal to start).</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 0, 0],</span>
<span class="diff-unchanged">          [0, 0, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">      </span>
<span class="diff-unchanged">      assert found is True, "Path should be found in a clear grid."</span>
<span class="diff-unchanged">      # Check that the path starts at the goal and ends at the start.</span>
<span class="diff-unchanged">      assert path[0] == goal, "Path should start with the goal node."</span>
<span class="diff-unchanged">      assert path[-1] == start, "Path should end with the start node."</span>
<span class="diff-unchanged">      # Optionally, check that the length of the path is reasonable (at least Manhattan distance + 1)</span>
<span class="diff-unchanged">      manhattan_distance = abs(goal.x - start.x) + abs(goal.y - start.y)</span>
<span class="diff-unchanged">      assert len(path) >= manhattan_distance + 1</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_no_path():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 2:</span>
<span class="diff-unchanged">      A 3x3 grid where the start is completely blocked off.</span>
<span class="diff-unchanged">      Start is at (0,0) and obstacles are placed so that there is no valid move.</span>
<span class="diff-unchanged">      The planner should return that no path is found.</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [1, 1, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">      assert found is False, "No path should be found if the start is blocked."</span>
<span class="diff-unchanged">      assert path == [], "Path should be empty when no path is found."</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_obstacle_detour():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 3:</span>
<span class="diff-unchanged">      A 3x3 grid with a vertical obstacle in the middle.</span>
<span class="diff-unchanged">      The start is at (0,0) and the goal is at (2,2). A detour is required.</span>
<span class="diff-unchanged">      We expect the planner to find a valid path.</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">      assert found is True, "A path should be found around the obstacle."</span>
<span class="diff-unchanged">      assert path[0] == goal, "Path should start with the goal node."</span>
<span class="diff-unchanged">      assert path[-1] == start, "Path should end with the start node."</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_goal_not_found():</span>
<span class="diff-unchanged">      planner = Dijkstra([[0]])</span>
<span class="diff-unchanged">      closed_list = set()</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(1, 1, 0)</span>
<span class="diff-unchanged">      path = planner.convert_closed_list_to_path(closed_list, start, goal)</span>
<span class="diff-unchanged">      assert path == []</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_node_repr():</span>
<span class="diff-unchanged">      node = Node(1, 2, 3, 4, 5)</span>
<span class="diff-unchanged">      expected_repr = "Node(x=1, y=2, cost=3, id=4, pid=5)"</span>
<span class="diff-unchanged">      assert repr(node) == expected_repr</span>
<span class="diff-added">+ </span>
<span class="diff-added">+ </span>
<span class="diff-added">+ def test_convert_closed_list_goal_not_in_closed_list():</span>
<span class="diff-added">+     planner = Dijkstra([[0]])</span>
<span class="diff-added">+     closed_list = {Node(0, 0)}</span>
<span class="diff-added">+     start = Node(0, 0, 0)</span>
<span class="diff-added">+     goal = Node(0, 1, 0)</span>
<span class="diff-added">+     path = planner.convert_closed_list_to_path(closed_list, start, goal)</span>
<span class="diff-added">+     assert path == []</span></code></pre>
                    </details>
                </td>
                <td>
                    <details>
                        <summary>View More</summary>
                        <div><strong>STDERR:</strong> <pre><code class="language-python"></code></pre></div>
                        <div><strong>STDOUT:</strong> <pre><code class="language-python">============================= test session starts ==============================
platform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0
rootdir: /home/thiuquan/code/maude/cover-agent/dijkstra
plugins: anyio-4.8.0, cov-6.0.0
collected 6 items

test_app.py ......                                                       [100%]

---------- coverage: platform linux, python 3.10.12-final-0 ----------
Name          Stmts   Miss Branch BrPart  Cover
-----------------------------------------------
app.py          106     17     32      3    86%
test_app.py      48      0      0      0   100%
-----------------------------------------------
TOTAL           154     17     32      3    89%
Coverage XML written to file coverage.xml


============================== 6 passed in 0.07s ===============================
</code></pre></div>
                        <div><strong>Test Code:</strong> <pre><code class="language-python">def test_convert_closed_list_goal_not_in_closed_list():
    planner = Dijkstra([[0]])
    closed_list = {Node(0, 0)}
    start = Node(0, 0, 0)
    goal = Node(0, 1, 0)
    path = planner.convert_closed_list_to_path(closed_list, start, goal)
    assert path == []
</code></pre></div>
                        <div><strong>Imports:</strong> <pre><code class="language-python">""
</code></pre></div>
                    </details>
                </td>
            </tr>
            
            <tr>
                <td class="status-FAIL">FAIL</td>
                <td>Test failed</td>
                <td>1</td>
                <td>python</td>
                <td>
                    <details>
                        <summary>View Full Code</summary>
                        <pre><code><span class="diff-unchanged">  import pytest</span>
<span class="diff-unchanged">  from app import Node, Dijkstra</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_simple_path():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 1:</span>
<span class="diff-unchanged">      A simple 3x3 grid with no obstacles. The start is at (0,0) and the goal is at (2,2).</span>
<span class="diff-unchanged">      We expect the planner to find a path.</span>
<span class="diff-unchanged">      Note: The returned path is in reverse order (goal to start).</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 0, 0],</span>
<span class="diff-unchanged">          [0, 0, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">      </span>
<span class="diff-unchanged">      assert found is True, "Path should be found in a clear grid."</span>
<span class="diff-unchanged">      # Check that the path starts at the goal and ends at the start.</span>
<span class="diff-unchanged">      assert path[0] == goal, "Path should start with the goal node."</span>
<span class="diff-unchanged">      assert path[-1] == start, "Path should end with the start node."</span>
<span class="diff-unchanged">      # Optionally, check that the length of the path is reasonable (at least Manhattan distance + 1)</span>
<span class="diff-unchanged">      manhattan_distance = abs(goal.x - start.x) + abs(goal.y - start.y)</span>
<span class="diff-unchanged">      assert len(path) >= manhattan_distance + 1</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_no_path():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 2:</span>
<span class="diff-unchanged">      A 3x3 grid where the start is completely blocked off.</span>
<span class="diff-unchanged">      Start is at (0,0) and obstacles are placed so that there is no valid move.</span>
<span class="diff-unchanged">      The planner should return that no path is found.</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [1, 1, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">      assert found is False, "No path should be found if the start is blocked."</span>
<span class="diff-unchanged">      assert path == [], "Path should be empty when no path is found."</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_obstacle_detour():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 3:</span>
<span class="diff-unchanged">      A 3x3 grid with a vertical obstacle in the middle.</span>
<span class="diff-unchanged">      The start is at (0,0) and the goal is at (2,2). A detour is required.</span>
<span class="diff-unchanged">      We expect the planner to find a valid path.</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">      assert found is True, "A path should be found around the obstacle."</span>
<span class="diff-unchanged">      assert path[0] == goal, "Path should start with the goal node."</span>
<span class="diff-unchanged">      assert path[-1] == start, "Path should end with the start node."</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_goal_not_found():</span>
<span class="diff-unchanged">      planner = Dijkstra([[0]])</span>
<span class="diff-unchanged">      closed_list = set()</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(1, 1, 0)</span>
<span class="diff-unchanged">      path = planner.convert_closed_list_to_path(closed_list, start, goal)</span>
<span class="diff-unchanged">      assert path == []</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_node_repr():</span>
<span class="diff-unchanged">      node = Node(1, 2, 3, 4, 5)</span>
<span class="diff-unchanged">      expected_repr = "Node(x=1, y=2, cost=3, id=4, pid=5)"</span>
<span class="diff-unchanged">      assert repr(node) == expected_repr</span>
<span class="diff-added">+ </span>
<span class="diff-added">+ </span>
<span class="diff-added">+ def test_convert_closed_list_parent_not_found():</span>
<span class="diff-added">+     planner = Dijkstra([[0, 0], [0, 0]])</span>
<span class="diff-added">+     start = Node(0, 0, 0)</span>
<span class="diff-added">+     goal = Node(1, 0, 0)</span>
<span class="diff-added">+     closed_list = {start, goal}</span>
<span class="diff-added">+     goal.pid = 0</span>
<span class="diff-added">+ </span>
<span class="diff-added">+     planner = Dijkstra([[0, 0], [0, 0]])</span>
<span class="diff-added">+     found, path = planner.plan(start, goal)</span>
<span class="diff-added">+     closed_list = planner.closed_list</span>
<span class="diff-added">+     path = planner.convert_closed_list_to_path(closed_list, start, goal)</span>
<span class="diff-added">+     assert path == []</span></code></pre>
                    </details>
                </td>
                <td>
                    <details>
                        <summary>View More</summary>
                        <div><strong>STDERR:</strong> <pre><code class="language-python"></code></pre></div>
                        <div><strong>STDOUT:</strong> <pre><code class="language-python">============================= test session starts ==============================
platform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0
rootdir: /home/thiuquan/code/maude/cover-agent/dijkstra
plugins: anyio-4.8.0, cov-6.0.0
collected 6 items

test_app.py .....F                                                       [100%]

=================================== FAILURES ===================================
__________________ test_convert_closed_list_parent_not_found ___________________

    def test_convert_closed_list_parent_not_found():
        planner = Dijkstra([[0, 0], [0, 0]])
        start = Node(0, 0, 0)
        goal = Node(1, 0, 0)
        closed_list = {start, goal}
        goal.pid = 0
    
        planner = Dijkstra([[0, 0], [0, 0]])
        found, path = planner.plan(start, goal)
>       closed_list = planner.closed_list
E       AttributeError: 'Dijkstra' object has no attribute 'closed_list'

test_app.py:95: AttributeError

---------- coverage: platform linux, python 3.10.12-final-0 ----------
Name          Stmts   Miss Branch BrPart  Cover
-----------------------------------------------
app.py          106     17     32      3    86%
test_app.py      52      2      0      0    96%
-----------------------------------------------
TOTAL           158     19     32      3    88%
Coverage XML written to file coverage.xml

=========================== short test summary info ============================
FAILED test_app.py::test_convert_closed_list_parent_not_found - AttributeErro...
========================= 1 failed, 5 passed in 0.08s ==========================
</code></pre></div>
                        <div><strong>Test Code:</strong> <pre><code class="language-python">def test_convert_closed_list_parent_not_found():
    planner = Dijkstra([[0, 0], [0, 0]])
    start = Node(0, 0, 0)
    goal = Node(1, 0, 0)
    closed_list = {start, goal}
    goal.pid = 0

    planner = Dijkstra([[0, 0], [0, 0]])
    found, path = planner.plan(start, goal)
    closed_list = planner.closed_list
    path = planner.convert_closed_list_to_path(closed_list, start, goal)
    assert path == []
</code></pre></div>
                        <div><strong>Imports:</strong> <pre><code class="language-python">""
</code></pre></div>
                    </details>
                </td>
            </tr>
            
            <tr>
                <td class="status-FAIL">FAIL</td>
                <td>Coverage did not increase</td>
                <td>0</td>
                <td>python</td>
                <td>
                    <details>
                        <summary>View Full Code</summary>
                        <pre><code><span class="diff-unchanged">  import pytest</span>
<span class="diff-unchanged">  from app import Node, Dijkstra</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_simple_path():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 1:</span>
<span class="diff-unchanged">      A simple 3x3 grid with no obstacles. The start is at (0,0) and the goal is at (2,2).</span>
<span class="diff-unchanged">      We expect the planner to find a path.</span>
<span class="diff-unchanged">      Note: The returned path is in reverse order (goal to start).</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 0, 0],</span>
<span class="diff-unchanged">          [0, 0, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">      </span>
<span class="diff-unchanged">      assert found is True, "Path should be found in a clear grid."</span>
<span class="diff-unchanged">      # Check that the path starts at the goal and ends at the start.</span>
<span class="diff-unchanged">      assert path[0] == goal, "Path should start with the goal node."</span>
<span class="diff-unchanged">      assert path[-1] == start, "Path should end with the start node."</span>
<span class="diff-unchanged">      # Optionally, check that the length of the path is reasonable (at least Manhattan distance + 1)</span>
<span class="diff-unchanged">      manhattan_distance = abs(goal.x - start.x) + abs(goal.y - start.y)</span>
<span class="diff-unchanged">      assert len(path) >= manhattan_distance + 1</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_no_path():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 2:</span>
<span class="diff-unchanged">      A 3x3 grid where the start is completely blocked off.</span>
<span class="diff-unchanged">      Start is at (0,0) and obstacles are placed so that there is no valid move.</span>
<span class="diff-unchanged">      The planner should return that no path is found.</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [1, 1, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">      assert found is False, "No path should be found if the start is blocked."</span>
<span class="diff-unchanged">      assert path == [], "Path should be empty when no path is found."</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_obstacle_detour():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 3:</span>
<span class="diff-unchanged">      A 3x3 grid with a vertical obstacle in the middle.</span>
<span class="diff-unchanged">      The start is at (0,0) and the goal is at (2,2). A detour is required.</span>
<span class="diff-unchanged">      We expect the planner to find a valid path.</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">      assert found is True, "A path should be found around the obstacle."</span>
<span class="diff-unchanged">      assert path[0] == goal, "Path should start with the goal node."</span>
<span class="diff-unchanged">      assert path[-1] == start, "Path should end with the start node."</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_goal_not_found():</span>
<span class="diff-unchanged">      planner = Dijkstra([[0]])</span>
<span class="diff-unchanged">      closed_list = set()</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(1, 1, 0)</span>
<span class="diff-unchanged">      path = planner.convert_closed_list_to_path(closed_list, start, goal)</span>
<span class="diff-unchanged">      assert path == []</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_node_repr():</span>
<span class="diff-unchanged">      node = Node(1, 2, 3, 4, 5)</span>
<span class="diff-unchanged">      expected_repr = "Node(x=1, y=2, cost=3, id=4, pid=5)"</span>
<span class="diff-unchanged">      assert repr(node) == expected_repr</span>
<span class="diff-added">+ </span>
<span class="diff-added">+ </span>
<span class="diff-added">+ def test_start_equals_goal():</span>
<span class="diff-added">+     grid = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]</span>
<span class="diff-added">+     start = Node(1, 1, 0)</span>
<span class="diff-added">+     goal = Node(1, 1, 0)</span>
<span class="diff-added">+     planner = Dijkstra(grid)</span>
<span class="diff-added">+     found, path = planner.plan(start, goal)</span>
<span class="diff-added">+     assert found is True</span>
<span class="diff-added">+     assert path[0] == goal</span>
<span class="diff-added">+     assert path[-1] == start</span></code></pre>
                    </details>
                </td>
                <td>
                    <details>
                        <summary>View More</summary>
                        <div><strong>STDERR:</strong> <pre><code class="language-python"></code></pre></div>
                        <div><strong>STDOUT:</strong> <pre><code class="language-python">============================= test session starts ==============================
platform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0
rootdir: /home/thiuquan/code/maude/cover-agent/dijkstra
plugins: anyio-4.8.0, cov-6.0.0
collected 6 items

test_app.py ......                                                       [100%]

---------- coverage: platform linux, python 3.10.12-final-0 ----------
Name          Stmts   Miss Branch BrPart  Cover
-----------------------------------------------
app.py          106     17     32      3    86%
test_app.py      50      0      0      0   100%
-----------------------------------------------
TOTAL           156     17     32      3    89%
Coverage XML written to file coverage.xml


============================== 6 passed in 0.08s ===============================
</code></pre></div>
                        <div><strong>Test Code:</strong> <pre><code class="language-python">def test_start_equals_goal():
    grid = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]
    start = Node(1, 1, 0)
    goal = Node(1, 1, 0)
    planner = Dijkstra(grid)
    found, path = planner.plan(start, goal)
    assert found is True
    assert path[0] == goal
    assert path[-1] == start
</code></pre></div>
                        <div><strong>Imports:</strong> <pre><code class="language-python">""
</code></pre></div>
                    </details>
                </td>
            </tr>
            
            <tr>
                <td class="status-FAIL">FAIL</td>
                <td>Coverage did not increase</td>
                <td>0</td>
                <td>python</td>
                <td>
                    <details>
                        <summary>View Full Code</summary>
                        <pre><code><span class="diff-unchanged">  import pytest</span>
<span class="diff-unchanged">  from app import Node, Dijkstra</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_simple_path():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 1:</span>
<span class="diff-unchanged">      A simple 3x3 grid with no obstacles. The start is at (0,0) and the goal is at (2,2).</span>
<span class="diff-unchanged">      We expect the planner to find a path.</span>
<span class="diff-unchanged">      Note: The returned path is in reverse order (goal to start).</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 0, 0],</span>
<span class="diff-unchanged">          [0, 0, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">      </span>
<span class="diff-unchanged">      assert found is True, "Path should be found in a clear grid."</span>
<span class="diff-unchanged">      # Check that the path starts at the goal and ends at the start.</span>
<span class="diff-unchanged">      assert path[0] == goal, "Path should start with the goal node."</span>
<span class="diff-unchanged">      assert path[-1] == start, "Path should end with the start node."</span>
<span class="diff-unchanged">      # Optionally, check that the length of the path is reasonable (at least Manhattan distance + 1)</span>
<span class="diff-unchanged">      manhattan_distance = abs(goal.x - start.x) + abs(goal.y - start.y)</span>
<span class="diff-unchanged">      assert len(path) >= manhattan_distance + 1</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_no_path():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 2:</span>
<span class="diff-unchanged">      A 3x3 grid where the start is completely blocked off.</span>
<span class="diff-unchanged">      Start is at (0,0) and obstacles are placed so that there is no valid move.</span>
<span class="diff-unchanged">      The planner should return that no path is found.</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [1, 1, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">      assert found is False, "No path should be found if the start is blocked."</span>
<span class="diff-unchanged">      assert path == [], "Path should be empty when no path is found."</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_obstacle_detour():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 3:</span>
<span class="diff-unchanged">      A 3x3 grid with a vertical obstacle in the middle.</span>
<span class="diff-unchanged">      The start is at (0,0) and the goal is at (2,2). A detour is required.</span>
<span class="diff-unchanged">      We expect the planner to find a valid path.</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">      assert found is True, "A path should be found around the obstacle."</span>
<span class="diff-unchanged">      assert path[0] == goal, "Path should start with the goal node."</span>
<span class="diff-unchanged">      assert path[-1] == start, "Path should end with the start node."</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_goal_not_found():</span>
<span class="diff-unchanged">      planner = Dijkstra([[0]])</span>
<span class="diff-unchanged">      closed_list = set()</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(1, 1, 0)</span>
<span class="diff-unchanged">      path = planner.convert_closed_list_to_path(closed_list, start, goal)</span>
<span class="diff-unchanged">      assert path == []</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_node_repr():</span>
<span class="diff-unchanged">      node = Node(1, 2, 3, 4, 5)</span>
<span class="diff-unchanged">      expected_repr = "Node(x=1, y=2, cost=3, id=4, pid=5)"</span>
<span class="diff-unchanged">      assert repr(node) == expected_repr</span>
<span class="diff-added">+ </span>
<span class="diff-added">+ </span>
<span class="diff-added">+ def test_goal_unreachable_row_obstacle():</span>
<span class="diff-added">+     n = 3</span>
<span class="diff-added">+     grid = [</span>
<span class="diff-added">+         [0, 0, 0],</span>
<span class="diff-added">+         [1, 1, 1],</span>
<span class="diff-added">+         [0, 0, 0]</span>
<span class="diff-added">+     ]</span>
<span class="diff-added">+     start = Node(0, 0, 0)</span>
<span class="diff-added">+     goal = Node(2, 2, 0)</span>
<span class="diff-added">+     start.id = start.x * n + start.y</span>
<span class="diff-added">+     start.pid = start.id</span>
<span class="diff-added">+     goal.id = goal.x * n + goal.y</span>
<span class="diff-added">+     grid[start.x][start.y] = 0</span>
<span class="diff-added">+     grid[goal.x][goal.y] = 0</span>
<span class="diff-added">+ </span>
<span class="diff-added">+     planner = Dijkstra(grid)</span>
<span class="diff-added">+     found, path = planner.plan(start, goal)</span>
<span class="diff-added">+ </span>
<span class="diff-added">+     assert found is False</span>
<span class="diff-added">+     assert path == []</span></code></pre>
                    </details>
                </td>
                <td>
                    <details>
                        <summary>View More</summary>
                        <div><strong>STDERR:</strong> <pre><code class="language-python"></code></pre></div>
                        <div><strong>STDOUT:</strong> <pre><code class="language-python">============================= test session starts ==============================
platform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0
rootdir: /home/thiuquan/code/maude/cover-agent/dijkstra
plugins: anyio-4.8.0, cov-6.0.0
collected 6 items

test_app.py ......                                                       [100%]

---------- coverage: platform linux, python 3.10.12-final-0 ----------
Name          Stmts   Miss Branch BrPart  Cover
-----------------------------------------------
app.py          106     17     32      3    86%
test_app.py      55      0      0      0   100%
-----------------------------------------------
TOTAL           161     17     32      3    90%
Coverage XML written to file coverage.xml


============================== 6 passed in 0.09s ===============================
</code></pre></div>
                        <div><strong>Test Code:</strong> <pre><code class="language-python">def test_goal_unreachable_row_obstacle():
    n = 3
    grid = [
        [0, 0, 0],
        [1, 1, 1],
        [0, 0, 0]
    ]
    start = Node(0, 0, 0)
    goal = Node(2, 2, 0)
    start.id = start.x * n + start.y
    start.pid = start.id
    goal.id = goal.x * n + goal.y
    grid[start.x][start.y] = 0
    grid[goal.x][goal.y] = 0

    planner = Dijkstra(grid)
    found, path = planner.plan(start, goal)

    assert found is False
    assert path == []
</code></pre></div>
                        <div><strong>Imports:</strong> <pre><code class="language-python">""
</code></pre></div>
                    </details>
                </td>
            </tr>
            
            <tr>
                <td class="status-FAIL">FAIL</td>
                <td>Coverage did not increase</td>
                <td>0</td>
                <td>python</td>
                <td>
                    <details>
                        <summary>View Full Code</summary>
                        <pre><code><span class="diff-unchanged">  import pytest</span>
<span class="diff-unchanged">  from app import Node, Dijkstra</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_simple_path():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 1:</span>
<span class="diff-unchanged">      A simple 3x3 grid with no obstacles. The start is at (0,0) and the goal is at (2,2).</span>
<span class="diff-unchanged">      We expect the planner to find a path.</span>
<span class="diff-unchanged">      Note: The returned path is in reverse order (goal to start).</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 0, 0],</span>
<span class="diff-unchanged">          [0, 0, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">      </span>
<span class="diff-unchanged">      assert found is True, "Path should be found in a clear grid."</span>
<span class="diff-unchanged">      # Check that the path starts at the goal and ends at the start.</span>
<span class="diff-unchanged">      assert path[0] == goal, "Path should start with the goal node."</span>
<span class="diff-unchanged">      assert path[-1] == start, "Path should end with the start node."</span>
<span class="diff-unchanged">      # Optionally, check that the length of the path is reasonable (at least Manhattan distance + 1)</span>
<span class="diff-unchanged">      manhattan_distance = abs(goal.x - start.x) + abs(goal.y - start.y)</span>
<span class="diff-unchanged">      assert len(path) >= manhattan_distance + 1</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_no_path():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 2:</span>
<span class="diff-unchanged">      A 3x3 grid where the start is completely blocked off.</span>
<span class="diff-unchanged">      Start is at (0,0) and obstacles are placed so that there is no valid move.</span>
<span class="diff-unchanged">      The planner should return that no path is found.</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [1, 1, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">      assert found is False, "No path should be found if the start is blocked."</span>
<span class="diff-unchanged">      assert path == [], "Path should be empty when no path is found."</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_obstacle_detour():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 3:</span>
<span class="diff-unchanged">      A 3x3 grid with a vertical obstacle in the middle.</span>
<span class="diff-unchanged">      The start is at (0,0) and the goal is at (2,2). A detour is required.</span>
<span class="diff-unchanged">      We expect the planner to find a valid path.</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">      assert found is True, "A path should be found around the obstacle."</span>
<span class="diff-unchanged">      assert path[0] == goal, "Path should start with the goal node."</span>
<span class="diff-unchanged">      assert path[-1] == start, "Path should end with the start node."</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_goal_not_found():</span>
<span class="diff-unchanged">      planner = Dijkstra([[0]])</span>
<span class="diff-unchanged">      closed_list = set()</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(1, 1, 0)</span>
<span class="diff-unchanged">      path = planner.convert_closed_list_to_path(closed_list, start, goal)</span>
<span class="diff-unchanged">      assert path == []</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_node_repr():</span>
<span class="diff-unchanged">      node = Node(1, 2, 3, 4, 5)</span>
<span class="diff-unchanged">      expected_repr = "Node(x=1, y=2, cost=3, id=4, pid=5)"</span>
<span class="diff-unchanged">      assert repr(node) == expected_repr</span>
<span class="diff-added">+ </span>
<span class="diff-added">+ </span>
<span class="diff-added">+ def test_convert_closed_list_goal_not_in_closed_list():</span>
<span class="diff-added">+     planner = Dijkstra([[0]])</span>
<span class="diff-added">+     closed_list = {Node(0, 0)}</span>
<span class="diff-added">+     start = Node(0, 0, 0)</span>
<span class="diff-added">+     goal = Node(0, 1, 0)</span>
<span class="diff-added">+     path = planner.convert_closed_list_to_path(closed_list, start, goal)</span>
<span class="diff-added">+     assert path == []</span></code></pre>
                    </details>
                </td>
                <td>
                    <details>
                        <summary>View More</summary>
                        <div><strong>STDERR:</strong> <pre><code class="language-python"></code></pre></div>
                        <div><strong>STDOUT:</strong> <pre><code class="language-python">============================= test session starts ==============================
platform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0
rootdir: /home/thiuquan/code/maude/cover-agent/dijkstra
plugins: anyio-4.8.0, cov-6.0.0
collected 6 items

test_app.py ......                                                       [100%]

---------- coverage: platform linux, python 3.10.12-final-0 ----------
Name          Stmts   Miss Branch BrPart  Cover
-----------------------------------------------
app.py          106     17     32      3    86%
test_app.py      48      0      0      0   100%
-----------------------------------------------
TOTAL           154     17     32      3    89%
Coverage XML written to file coverage.xml


============================== 6 passed in 0.08s ===============================
</code></pre></div>
                        <div><strong>Test Code:</strong> <pre><code class="language-python">def test_convert_closed_list_goal_not_in_closed_list():
    planner = Dijkstra([[0]])
    closed_list = {Node(0, 0)}
    start = Node(0, 0, 0)
    goal = Node(0, 1, 0)
    path = planner.convert_closed_list_to_path(closed_list, start, goal)
    assert path == []
</code></pre></div>
                        <div><strong>Imports:</strong> <pre><code class="language-python">""
</code></pre></div>
                    </details>
                </td>
            </tr>
            
            <tr>
                <td class="status-FAIL">FAIL</td>
                <td>Test failed</td>
                <td>1</td>
                <td>python</td>
                <td>
                    <details>
                        <summary>View Full Code</summary>
                        <pre><code><span class="diff-unchanged">  import pytest</span>
<span class="diff-unchanged">  from app import Node, Dijkstra</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_simple_path():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 1:</span>
<span class="diff-unchanged">      A simple 3x3 grid with no obstacles. The start is at (0,0) and the goal is at (2,2).</span>
<span class="diff-unchanged">      We expect the planner to find a path.</span>
<span class="diff-unchanged">      Note: The returned path is in reverse order (goal to start).</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 0, 0],</span>
<span class="diff-unchanged">          [0, 0, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">      </span>
<span class="diff-unchanged">      assert found is True, "Path should be found in a clear grid."</span>
<span class="diff-unchanged">      # Check that the path starts at the goal and ends at the start.</span>
<span class="diff-unchanged">      assert path[0] == goal, "Path should start with the goal node."</span>
<span class="diff-unchanged">      assert path[-1] == start, "Path should end with the start node."</span>
<span class="diff-unchanged">      # Optionally, check that the length of the path is reasonable (at least Manhattan distance + 1)</span>
<span class="diff-unchanged">      manhattan_distance = abs(goal.x - start.x) + abs(goal.y - start.y)</span>
<span class="diff-unchanged">      assert len(path) >= manhattan_distance + 1</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_no_path():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 2:</span>
<span class="diff-unchanged">      A 3x3 grid where the start is completely blocked off.</span>
<span class="diff-unchanged">      Start is at (0,0) and obstacles are placed so that there is no valid move.</span>
<span class="diff-unchanged">      The planner should return that no path is found.</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [1, 1, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">      assert found is False, "No path should be found if the start is blocked."</span>
<span class="diff-unchanged">      assert path == [], "Path should be empty when no path is found."</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_obstacle_detour():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 3:</span>
<span class="diff-unchanged">      A 3x3 grid with a vertical obstacle in the middle.</span>
<span class="diff-unchanged">      The start is at (0,0) and the goal is at (2,2). A detour is required.</span>
<span class="diff-unchanged">      We expect the planner to find a valid path.</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">      assert found is True, "A path should be found around the obstacle."</span>
<span class="diff-unchanged">      assert path[0] == goal, "Path should start with the goal node."</span>
<span class="diff-unchanged">      assert path[-1] == start, "Path should end with the start node."</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_goal_not_found():</span>
<span class="diff-unchanged">      planner = Dijkstra([[0]])</span>
<span class="diff-unchanged">      closed_list = set()</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(1, 1, 0)</span>
<span class="diff-unchanged">      path = planner.convert_closed_list_to_path(closed_list, start, goal)</span>
<span class="diff-unchanged">      assert path == []</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_node_repr():</span>
<span class="diff-unchanged">      node = Node(1, 2, 3, 4, 5)</span>
<span class="diff-unchanged">      expected_repr = "Node(x=1, y=2, cost=3, id=4, pid=5)"</span>
<span class="diff-unchanged">      assert repr(node) == expected_repr</span>
<span class="diff-added">+ </span>
<span class="diff-added">+ </span>
<span class="diff-added">+ def test_convert_closed_list_parent_not_found():</span>
<span class="diff-added">+     planner = Dijkstra([[0, 0], [0, 0]])</span>
<span class="diff-added">+     start = Node(0, 0, 0)</span>
<span class="diff-added">+     goal = Node(1, 0, 0)</span>
<span class="diff-added">+     closed_list = {start, goal}</span>
<span class="diff-added">+     goal.pid = None</span>
<span class="diff-added">+ </span>
<span class="diff-added">+     path = planner.convert_closed_list_to_path(closed_list, start, goal)</span>
<span class="diff-added">+     assert path == []</span></code></pre>
                    </details>
                </td>
                <td>
                    <details>
                        <summary>View More</summary>
                        <div><strong>STDERR:</strong> <pre><code class="language-python"></code></pre></div>
                        <div><strong>STDOUT:</strong> <pre><code class="language-python">============================= test session starts ==============================
platform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0
rootdir: /home/thiuquan/code/maude/cover-agent/dijkstra
plugins: anyio-4.8.0, cov-6.0.0
collected 6 items

test_app.py .....F                                                       [100%]

=================================== FAILURES ===================================
__________________ test_convert_closed_list_parent_not_found ___________________

    def test_convert_closed_list_parent_not_found():
        planner = Dijkstra([[0, 0], [0, 0]])
        start = Node(0, 0, 0)
        goal = Node(1, 0, 0)
        closed_list = {start, goal}
        goal.pid = None
    
>       path = planner.convert_closed_list_to_path(closed_list, start, goal)

test_app.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <app.Dijkstra object at 0x7f9b1ee02350>
closed_list = {Node(x=1, y=0, cost=0, id=None, pid=None), Node(x=0, y=0, cost=0, id=None, pid=None)}
start = Node(x=0, y=0, cost=0, id=None, pid=None)
goal = Node(x=1, y=0, cost=0, id=None, pid=None)

    def convert_closed_list_to_path(self, closed_list, start, goal):
        """
        Converts the closed list (visited nodes) into a path from goal to start.
        Backtracks from the goal node using the stored parent ids (pid).
        """
        current = None
        # Find the node in closed_list that matches the goal coordinates.
        for node in closed_list:
            if compare_coordinates(node, goal):
                current = node
                break
    
        if current is None:
            print("Error in calculating path")
            return []
    
        path = []
        # Backtrack until we reach the start.
        while not compare_coordinates(current, start):
            path.append(current)
>           parent_x = current.pid // self.n
E           TypeError: unsupported operand type(s) for //: 'NoneType' and 'int'

app.py:144: TypeError

---------- coverage: platform linux, python 3.10.12-final-0 ----------
Name          Stmts   Miss Branch BrPart  Cover
-----------------------------------------------
app.py          106     17     32      3    86%
test_app.py      49      1      0      0    98%
-----------------------------------------------
TOTAL           155     18     32      3    89%
Coverage XML written to file coverage.xml

=========================== short test summary info ============================
FAILED test_app.py::test_convert_closed_list_parent_not_found - TypeError: un...
========================= 1 failed, 5 passed in 0.11s ==========================
</code></pre></div>
                        <div><strong>Test Code:</strong> <pre><code class="language-python">def test_convert_closed_list_parent_not_found():
    planner = Dijkstra([[0, 0], [0, 0]])
    start = Node(0, 0, 0)
    goal = Node(1, 0, 0)
    closed_list = {start, goal}
    goal.pid = None

    path = planner.convert_closed_list_to_path(closed_list, start, goal)
    assert path == []
</code></pre></div>
                        <div><strong>Imports:</strong> <pre><code class="language-python">""
</code></pre></div>
                    </details>
                </td>
            </tr>
            
            <tr>
                <td class="status-FAIL">FAIL</td>
                <td>Coverage did not increase</td>
                <td>0</td>
                <td>python</td>
                <td>
                    <details>
                        <summary>View Full Code</summary>
                        <pre><code><span class="diff-unchanged">  import pytest</span>
<span class="diff-unchanged">  from app import Node, Dijkstra</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_simple_path():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 1:</span>
<span class="diff-unchanged">      A simple 3x3 grid with no obstacles. The start is at (0,0) and the goal is at (2,2).</span>
<span class="diff-unchanged">      We expect the planner to find a path.</span>
<span class="diff-unchanged">      Note: The returned path is in reverse order (goal to start).</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 0, 0],</span>
<span class="diff-unchanged">          [0, 0, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">      </span>
<span class="diff-unchanged">      assert found is True, "Path should be found in a clear grid."</span>
<span class="diff-unchanged">      # Check that the path starts at the goal and ends at the start.</span>
<span class="diff-unchanged">      assert path[0] == goal, "Path should start with the goal node."</span>
<span class="diff-unchanged">      assert path[-1] == start, "Path should end with the start node."</span>
<span class="diff-unchanged">      # Optionally, check that the length of the path is reasonable (at least Manhattan distance + 1)</span>
<span class="diff-unchanged">      manhattan_distance = abs(goal.x - start.x) + abs(goal.y - start.y)</span>
<span class="diff-unchanged">      assert len(path) >= manhattan_distance + 1</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_no_path():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 2:</span>
<span class="diff-unchanged">      A 3x3 grid where the start is completely blocked off.</span>
<span class="diff-unchanged">      Start is at (0,0) and obstacles are placed so that there is no valid move.</span>
<span class="diff-unchanged">      The planner should return that no path is found.</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [1, 1, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">      assert found is False, "No path should be found if the start is blocked."</span>
<span class="diff-unchanged">      assert path == [], "Path should be empty when no path is found."</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_obstacle_detour():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 3:</span>
<span class="diff-unchanged">      A 3x3 grid with a vertical obstacle in the middle.</span>
<span class="diff-unchanged">      The start is at (0,0) and the goal is at (2,2). A detour is required.</span>
<span class="diff-unchanged">      We expect the planner to find a valid path.</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">      assert found is True, "A path should be found around the obstacle."</span>
<span class="diff-unchanged">      assert path[0] == goal, "Path should start with the goal node."</span>
<span class="diff-unchanged">      assert path[-1] == start, "Path should end with the start node."</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_goal_not_found():</span>
<span class="diff-unchanged">      planner = Dijkstra([[0]])</span>
<span class="diff-unchanged">      closed_list = set()</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(1, 1, 0)</span>
<span class="diff-unchanged">      path = planner.convert_closed_list_to_path(closed_list, start, goal)</span>
<span class="diff-unchanged">      assert path == []</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_node_repr():</span>
<span class="diff-unchanged">      node = Node(1, 2, 3, 4, 5)</span>
<span class="diff-unchanged">      expected_repr = "Node(x=1, y=2, cost=3, id=4, pid=5)"</span>
<span class="diff-unchanged">      assert repr(node) == expected_repr</span>
<span class="diff-added">+ </span>
<span class="diff-added">+ </span>
<span class="diff-added">+ def test_start_equals_goal():</span>
<span class="diff-added">+     grid = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]</span>
<span class="diff-added">+     start = Node(1, 1, 0)</span>
<span class="diff-added">+     goal = Node(1, 1, 0)</span>
<span class="diff-added">+     planner = Dijkstra(grid)</span>
<span class="diff-added">+     found, path = planner.plan(start, goal)</span>
<span class="diff-added">+     assert found is True</span>
<span class="diff-added">+     assert path[0] == goal</span>
<span class="diff-added">+     assert path[-1] == start</span></code></pre>
                    </details>
                </td>
                <td>
                    <details>
                        <summary>View More</summary>
                        <div><strong>STDERR:</strong> <pre><code class="language-python"></code></pre></div>
                        <div><strong>STDOUT:</strong> <pre><code class="language-python">============================= test session starts ==============================
platform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0
rootdir: /home/thiuquan/code/maude/cover-agent/dijkstra
plugins: anyio-4.8.0, cov-6.0.0
collected 6 items

test_app.py ......                                                       [100%]

---------- coverage: platform linux, python 3.10.12-final-0 ----------
Name          Stmts   Miss Branch BrPart  Cover
-----------------------------------------------
app.py          106     17     32      3    86%
test_app.py      50      0      0      0   100%
-----------------------------------------------
TOTAL           156     17     32      3    89%
Coverage XML written to file coverage.xml


============================== 6 passed in 0.09s ===============================
</code></pre></div>
                        <div><strong>Test Code:</strong> <pre><code class="language-python">def test_start_equals_goal():
    grid = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]
    start = Node(1, 1, 0)
    goal = Node(1, 1, 0)
    planner = Dijkstra(grid)
    found, path = planner.plan(start, goal)
    assert found is True
    assert path[0] == goal
    assert path[-1] == start
</code></pre></div>
                        <div><strong>Imports:</strong> <pre><code class="language-python">""
</code></pre></div>
                    </details>
                </td>
            </tr>
            
            <tr>
                <td class="status-FAIL">FAIL</td>
                <td>Coverage did not increase</td>
                <td>0</td>
                <td>python</td>
                <td>
                    <details>
                        <summary>View Full Code</summary>
                        <pre><code><span class="diff-unchanged">  import pytest</span>
<span class="diff-unchanged">  from app import Node, Dijkstra</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_simple_path():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 1:</span>
<span class="diff-unchanged">      A simple 3x3 grid with no obstacles. The start is at (0,0) and the goal is at (2,2).</span>
<span class="diff-unchanged">      We expect the planner to find a path.</span>
<span class="diff-unchanged">      Note: The returned path is in reverse order (goal to start).</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 0, 0],</span>
<span class="diff-unchanged">          [0, 0, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">      </span>
<span class="diff-unchanged">      assert found is True, "Path should be found in a clear grid."</span>
<span class="diff-unchanged">      # Check that the path starts at the goal and ends at the start.</span>
<span class="diff-unchanged">      assert path[0] == goal, "Path should start with the goal node."</span>
<span class="diff-unchanged">      assert path[-1] == start, "Path should end with the start node."</span>
<span class="diff-unchanged">      # Optionally, check that the length of the path is reasonable (at least Manhattan distance + 1)</span>
<span class="diff-unchanged">      manhattan_distance = abs(goal.x - start.x) + abs(goal.y - start.y)</span>
<span class="diff-unchanged">      assert len(path) >= manhattan_distance + 1</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_no_path():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 2:</span>
<span class="diff-unchanged">      A 3x3 grid where the start is completely blocked off.</span>
<span class="diff-unchanged">      Start is at (0,0) and obstacles are placed so that there is no valid move.</span>
<span class="diff-unchanged">      The planner should return that no path is found.</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [1, 1, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">      assert found is False, "No path should be found if the start is blocked."</span>
<span class="diff-unchanged">      assert path == [], "Path should be empty when no path is found."</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_obstacle_detour():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 3:</span>
<span class="diff-unchanged">      A 3x3 grid with a vertical obstacle in the middle.</span>
<span class="diff-unchanged">      The start is at (0,0) and the goal is at (2,2). A detour is required.</span>
<span class="diff-unchanged">      We expect the planner to find a valid path.</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">      assert found is True, "A path should be found around the obstacle."</span>
<span class="diff-unchanged">      assert path[0] == goal, "Path should start with the goal node."</span>
<span class="diff-unchanged">      assert path[-1] == start, "Path should end with the start node."</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_goal_not_found():</span>
<span class="diff-unchanged">      planner = Dijkstra([[0]])</span>
<span class="diff-unchanged">      closed_list = set()</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(1, 1, 0)</span>
<span class="diff-unchanged">      path = planner.convert_closed_list_to_path(closed_list, start, goal)</span>
<span class="diff-unchanged">      assert path == []</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_node_repr():</span>
<span class="diff-unchanged">      node = Node(1, 2, 3, 4, 5)</span>
<span class="diff-unchanged">      expected_repr = "Node(x=1, y=2, cost=3, id=4, pid=5)"</span>
<span class="diff-unchanged">      assert repr(node) == expected_repr</span>
<span class="diff-added">+ </span>
<span class="diff-added">+ </span>
<span class="diff-added">+ def test_goal_unreachable_row_obstacle():</span>
<span class="diff-added">+     n = 3</span>
<span class="diff-added">+     grid = [</span>
<span class="diff-added">+         [0, 0, 0],</span>
<span class="diff-added">+         [1, 1, 1],</span>
<span class="diff-added">+         [0, 0, 0]</span>
<span class="diff-added">+     ]</span>
<span class="diff-added">+     start = Node(0, 0, 0)</span>
<span class="diff-added">+     goal = Node(2, 2, 0)</span>
<span class="diff-added">+     start.id = start.x * n + start.y</span>
<span class="diff-added">+     start.pid = start.id</span>
<span class="diff-added">+     goal.id = goal.x * n + goal.y</span>
<span class="diff-added">+     grid[start.x][start.y] = 0</span>
<span class="diff-added">+     grid[goal.x][goal.y] = 0</span>
<span class="diff-added">+ </span>
<span class="diff-added">+     planner = Dijkstra(grid)</span>
<span class="diff-added">+     found, path = planner.plan(start, goal)</span>
<span class="diff-added">+ </span>
<span class="diff-added">+     assert found is False</span>
<span class="diff-added">+     assert path == []</span></code></pre>
                    </details>
                </td>
                <td>
                    <details>
                        <summary>View More</summary>
                        <div><strong>STDERR:</strong> <pre><code class="language-python"></code></pre></div>
                        <div><strong>STDOUT:</strong> <pre><code class="language-python">============================= test session starts ==============================
platform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0
rootdir: /home/thiuquan/code/maude/cover-agent/dijkstra
plugins: anyio-4.8.0, cov-6.0.0
collected 6 items

test_app.py ......                                                       [100%]

---------- coverage: platform linux, python 3.10.12-final-0 ----------
Name          Stmts   Miss Branch BrPart  Cover
-----------------------------------------------
app.py          106     17     32      3    86%
test_app.py      55      0      0      0   100%
-----------------------------------------------
TOTAL           161     17     32      3    90%
Coverage XML written to file coverage.xml


============================== 6 passed in 0.08s ===============================
</code></pre></div>
                        <div><strong>Test Code:</strong> <pre><code class="language-python">def test_goal_unreachable_row_obstacle():
    n = 3
    grid = [
        [0, 0, 0],
        [1, 1, 1],
        [0, 0, 0]
    ]
    start = Node(0, 0, 0)
    goal = Node(2, 2, 0)
    start.id = start.x * n + start.y
    start.pid = start.id
    goal.id = goal.x * n + goal.y
    grid[start.x][start.y] = 0
    grid[goal.x][goal.y] = 0

    planner = Dijkstra(grid)
    found, path = planner.plan(start, goal)

    assert found is False
    assert path == []
</code></pre></div>
                        <div><strong>Imports:</strong> <pre><code class="language-python">""
</code></pre></div>
                    </details>
                </td>
            </tr>
            
            <tr>
                <td class="status-FAIL">FAIL</td>
                <td>Coverage did not increase</td>
                <td>0</td>
                <td>python</td>
                <td>
                    <details>
                        <summary>View Full Code</summary>
                        <pre><code><span class="diff-unchanged">  import pytest</span>
<span class="diff-unchanged">  from app import Node, Dijkstra</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_simple_path():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 1:</span>
<span class="diff-unchanged">      A simple 3x3 grid with no obstacles. The start is at (0,0) and the goal is at (2,2).</span>
<span class="diff-unchanged">      We expect the planner to find a path.</span>
<span class="diff-unchanged">      Note: The returned path is in reverse order (goal to start).</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 0, 0],</span>
<span class="diff-unchanged">          [0, 0, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">      </span>
<span class="diff-unchanged">      assert found is True, "Path should be found in a clear grid."</span>
<span class="diff-unchanged">      # Check that the path starts at the goal and ends at the start.</span>
<span class="diff-unchanged">      assert path[0] == goal, "Path should start with the goal node."</span>
<span class="diff-unchanged">      assert path[-1] == start, "Path should end with the start node."</span>
<span class="diff-unchanged">      # Optionally, check that the length of the path is reasonable (at least Manhattan distance + 1)</span>
<span class="diff-unchanged">      manhattan_distance = abs(goal.x - start.x) + abs(goal.y - start.y)</span>
<span class="diff-unchanged">      assert len(path) >= manhattan_distance + 1</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_no_path():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 2:</span>
<span class="diff-unchanged">      A 3x3 grid where the start is completely blocked off.</span>
<span class="diff-unchanged">      Start is at (0,0) and obstacles are placed so that there is no valid move.</span>
<span class="diff-unchanged">      The planner should return that no path is found.</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [1, 1, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">      assert found is False, "No path should be found if the start is blocked."</span>
<span class="diff-unchanged">      assert path == [], "Path should be empty when no path is found."</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_obstacle_detour():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 3:</span>
<span class="diff-unchanged">      A 3x3 grid with a vertical obstacle in the middle.</span>
<span class="diff-unchanged">      The start is at (0,0) and the goal is at (2,2). A detour is required.</span>
<span class="diff-unchanged">      We expect the planner to find a valid path.</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">      assert found is True, "A path should be found around the obstacle."</span>
<span class="diff-unchanged">      assert path[0] == goal, "Path should start with the goal node."</span>
<span class="diff-unchanged">      assert path[-1] == start, "Path should end with the start node."</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_goal_not_found():</span>
<span class="diff-unchanged">      planner = Dijkstra([[0]])</span>
<span class="diff-unchanged">      closed_list = set()</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(1, 1, 0)</span>
<span class="diff-unchanged">      path = planner.convert_closed_list_to_path(closed_list, start, goal)</span>
<span class="diff-unchanged">      assert path == []</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_node_repr():</span>
<span class="diff-unchanged">      node = Node(1, 2, 3, 4, 5)</span>
<span class="diff-unchanged">      expected_repr = "Node(x=1, y=2, cost=3, id=4, pid=5)"</span>
<span class="diff-unchanged">      assert repr(node) == expected_repr</span>
<span class="diff-added">+ </span>
<span class="diff-added">+ </span>
<span class="diff-added">+ def test_convert_closed_list_goal_not_in_closed_list():</span>
<span class="diff-added">+     planner = Dijkstra([[0]])</span>
<span class="diff-added">+     closed_list = {Node(0, 0)}</span>
<span class="diff-added">+     start = Node(0, 0, 0)</span>
<span class="diff-added">+     goal = Node(0, 1, 0)</span>
<span class="diff-added">+     path = planner.convert_closed_list_to_path(closed_list, start, goal)</span>
<span class="diff-added">+     assert path == []</span></code></pre>
                    </details>
                </td>
                <td>
                    <details>
                        <summary>View More</summary>
                        <div><strong>STDERR:</strong> <pre><code class="language-python"></code></pre></div>
                        <div><strong>STDOUT:</strong> <pre><code class="language-python">============================= test session starts ==============================
platform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0
rootdir: /home/thiuquan/code/maude/cover-agent/dijkstra
plugins: anyio-4.8.0, cov-6.0.0
collected 6 items

test_app.py ......                                                       [100%]

---------- coverage: platform linux, python 3.10.12-final-0 ----------
Name          Stmts   Miss Branch BrPart  Cover
-----------------------------------------------
app.py          106     17     32      3    86%
test_app.py      48      0      0      0   100%
-----------------------------------------------
TOTAL           154     17     32      3    89%
Coverage XML written to file coverage.xml


============================== 6 passed in 0.08s ===============================
</code></pre></div>
                        <div><strong>Test Code:</strong> <pre><code class="language-python">def test_convert_closed_list_goal_not_in_closed_list():
    planner = Dijkstra([[0]])
    closed_list = {Node(0, 0)}
    start = Node(0, 0, 0)
    goal = Node(0, 1, 0)
    path = planner.convert_closed_list_to_path(closed_list, start, goal)
    assert path == []
</code></pre></div>
                        <div><strong>Imports:</strong> <pre><code class="language-python">""
</code></pre></div>
                    </details>
                </td>
            </tr>
            
            <tr>
                <td class="status-FAIL">FAIL</td>
                <td>Test failed</td>
                <td>1</td>
                <td>python</td>
                <td>
                    <details>
                        <summary>View Full Code</summary>
                        <pre><code><span class="diff-unchanged">  import pytest</span>
<span class="diff-unchanged">  from app import Node, Dijkstra</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_simple_path():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 1:</span>
<span class="diff-unchanged">      A simple 3x3 grid with no obstacles. The start is at (0,0) and the goal is at (2,2).</span>
<span class="diff-unchanged">      We expect the planner to find a path.</span>
<span class="diff-unchanged">      Note: The returned path is in reverse order (goal to start).</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 0, 0],</span>
<span class="diff-unchanged">          [0, 0, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">      </span>
<span class="diff-unchanged">      assert found is True, "Path should be found in a clear grid."</span>
<span class="diff-unchanged">      # Check that the path starts at the goal and ends at the start.</span>
<span class="diff-unchanged">      assert path[0] == goal, "Path should start with the goal node."</span>
<span class="diff-unchanged">      assert path[-1] == start, "Path should end with the start node."</span>
<span class="diff-unchanged">      # Optionally, check that the length of the path is reasonable (at least Manhattan distance + 1)</span>
<span class="diff-unchanged">      manhattan_distance = abs(goal.x - start.x) + abs(goal.y - start.y)</span>
<span class="diff-unchanged">      assert len(path) >= manhattan_distance + 1</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_no_path():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 2:</span>
<span class="diff-unchanged">      A 3x3 grid where the start is completely blocked off.</span>
<span class="diff-unchanged">      Start is at (0,0) and obstacles are placed so that there is no valid move.</span>
<span class="diff-unchanged">      The planner should return that no path is found.</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [1, 1, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">      assert found is False, "No path should be found if the start is blocked."</span>
<span class="diff-unchanged">      assert path == [], "Path should be empty when no path is found."</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_obstacle_detour():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 3:</span>
<span class="diff-unchanged">      A 3x3 grid with a vertical obstacle in the middle.</span>
<span class="diff-unchanged">      The start is at (0,0) and the goal is at (2,2). A detour is required.</span>
<span class="diff-unchanged">      We expect the planner to find a valid path.</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">      assert found is True, "A path should be found around the obstacle."</span>
<span class="diff-unchanged">      assert path[0] == goal, "Path should start with the goal node."</span>
<span class="diff-unchanged">      assert path[-1] == start, "Path should end with the start node."</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_goal_not_found():</span>
<span class="diff-unchanged">      planner = Dijkstra([[0]])</span>
<span class="diff-unchanged">      closed_list = set()</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(1, 1, 0)</span>
<span class="diff-unchanged">      path = planner.convert_closed_list_to_path(closed_list, start, goal)</span>
<span class="diff-unchanged">      assert path == []</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_node_repr():</span>
<span class="diff-unchanged">      node = Node(1, 2, 3, 4, 5)</span>
<span class="diff-unchanged">      expected_repr = "Node(x=1, y=2, cost=3, id=4, pid=5)"</span>
<span class="diff-unchanged">      assert repr(node) == expected_repr</span>
<span class="diff-added">+ </span>
<span class="diff-added">+ </span>
<span class="diff-added">+ def test_convert_closed_list_parent_not_found():</span>
<span class="diff-added">+     planner = Dijkstra([[0, 0], [0, 0]])</span>
<span class="diff-added">+     start = Node(0, 0, 0)</span>
<span class="diff-added">+     goal = Node(1, 0, 0)</span>
<span class="diff-added">+     closed_list = {start, goal}</span>
<span class="diff-added">+     goal.pid = None</span>
<span class="diff-added">+ </span>
<span class="diff-added">+     path = planner.convert_closed_list_to_path(closed_list, start, goal)</span>
<span class="diff-added">+     assert path == []</span></code></pre>
                    </details>
                </td>
                <td>
                    <details>
                        <summary>View More</summary>
                        <div><strong>STDERR:</strong> <pre><code class="language-python"></code></pre></div>
                        <div><strong>STDOUT:</strong> <pre><code class="language-python">============================= test session starts ==============================
platform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0
rootdir: /home/thiuquan/code/maude/cover-agent/dijkstra
plugins: anyio-4.8.0, cov-6.0.0
collected 6 items

test_app.py .....F                                                       [100%]

=================================== FAILURES ===================================
__________________ test_convert_closed_list_parent_not_found ___________________

    def test_convert_closed_list_parent_not_found():
        planner = Dijkstra([[0, 0], [0, 0]])
        start = Node(0, 0, 0)
        goal = Node(1, 0, 0)
        closed_list = {start, goal}
        goal.pid = None
    
>       path = planner.convert_closed_list_to_path(closed_list, start, goal)

test_app.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <app.Dijkstra object at 0x7f827629a350>
closed_list = {Node(x=1, y=0, cost=0, id=None, pid=None), Node(x=0, y=0, cost=0, id=None, pid=None)}
start = Node(x=0, y=0, cost=0, id=None, pid=None)
goal = Node(x=1, y=0, cost=0, id=None, pid=None)

    def convert_closed_list_to_path(self, closed_list, start, goal):
        """
        Converts the closed list (visited nodes) into a path from goal to start.
        Backtracks from the goal node using the stored parent ids (pid).
        """
        current = None
        # Find the node in closed_list that matches the goal coordinates.
        for node in closed_list:
            if compare_coordinates(node, goal):
                current = node
                break
    
        if current is None:
            print("Error in calculating path")
            return []
    
        path = []
        # Backtrack until we reach the start.
        while not compare_coordinates(current, start):
            path.append(current)
>           parent_x = current.pid // self.n
E           TypeError: unsupported operand type(s) for //: 'NoneType' and 'int'

app.py:144: TypeError

---------- coverage: platform linux, python 3.10.12-final-0 ----------
Name          Stmts   Miss Branch BrPart  Cover
-----------------------------------------------
app.py          106     17     32      3    86%
test_app.py      49      1      0      0    98%
-----------------------------------------------
TOTAL           155     18     32      3    89%
Coverage XML written to file coverage.xml

=========================== short test summary info ============================
FAILED test_app.py::test_convert_closed_list_parent_not_found - TypeError: un...
========================= 1 failed, 5 passed in 0.11s ==========================
</code></pre></div>
                        <div><strong>Test Code:</strong> <pre><code class="language-python">def test_convert_closed_list_parent_not_found():
    planner = Dijkstra([[0, 0], [0, 0]])
    start = Node(0, 0, 0)
    goal = Node(1, 0, 0)
    closed_list = {start, goal}
    goal.pid = None

    path = planner.convert_closed_list_to_path(closed_list, start, goal)
    assert path == []
</code></pre></div>
                        <div><strong>Imports:</strong> <pre><code class="language-python">""
</code></pre></div>
                    </details>
                </td>
            </tr>
            
            <tr>
                <td class="status-FAIL">FAIL</td>
                <td>Coverage did not increase</td>
                <td>0</td>
                <td>python</td>
                <td>
                    <details>
                        <summary>View Full Code</summary>
                        <pre><code><span class="diff-unchanged">  import pytest</span>
<span class="diff-unchanged">  from app import Node, Dijkstra</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_simple_path():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 1:</span>
<span class="diff-unchanged">      A simple 3x3 grid with no obstacles. The start is at (0,0) and the goal is at (2,2).</span>
<span class="diff-unchanged">      We expect the planner to find a path.</span>
<span class="diff-unchanged">      Note: The returned path is in reverse order (goal to start).</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 0, 0],</span>
<span class="diff-unchanged">          [0, 0, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">      </span>
<span class="diff-unchanged">      assert found is True, "Path should be found in a clear grid."</span>
<span class="diff-unchanged">      # Check that the path starts at the goal and ends at the start.</span>
<span class="diff-unchanged">      assert path[0] == goal, "Path should start with the goal node."</span>
<span class="diff-unchanged">      assert path[-1] == start, "Path should end with the start node."</span>
<span class="diff-unchanged">      # Optionally, check that the length of the path is reasonable (at least Manhattan distance + 1)</span>
<span class="diff-unchanged">      manhattan_distance = abs(goal.x - start.x) + abs(goal.y - start.y)</span>
<span class="diff-unchanged">      assert len(path) >= manhattan_distance + 1</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_no_path():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 2:</span>
<span class="diff-unchanged">      A 3x3 grid where the start is completely blocked off.</span>
<span class="diff-unchanged">      Start is at (0,0) and obstacles are placed so that there is no valid move.</span>
<span class="diff-unchanged">      The planner should return that no path is found.</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [1, 1, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">      assert found is False, "No path should be found if the start is blocked."</span>
<span class="diff-unchanged">      assert path == [], "Path should be empty when no path is found."</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_obstacle_detour():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 3:</span>
<span class="diff-unchanged">      A 3x3 grid with a vertical obstacle in the middle.</span>
<span class="diff-unchanged">      The start is at (0,0) and the goal is at (2,2). A detour is required.</span>
<span class="diff-unchanged">      We expect the planner to find a valid path.</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">      assert found is True, "A path should be found around the obstacle."</span>
<span class="diff-unchanged">      assert path[0] == goal, "Path should start with the goal node."</span>
<span class="diff-unchanged">      assert path[-1] == start, "Path should end with the start node."</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_goal_not_found():</span>
<span class="diff-unchanged">      planner = Dijkstra([[0]])</span>
<span class="diff-unchanged">      closed_list = set()</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(1, 1, 0)</span>
<span class="diff-unchanged">      path = planner.convert_closed_list_to_path(closed_list, start, goal)</span>
<span class="diff-unchanged">      assert path == []</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_node_repr():</span>
<span class="diff-unchanged">      node = Node(1, 2, 3, 4, 5)</span>
<span class="diff-unchanged">      expected_repr = "Node(x=1, y=2, cost=3, id=4, pid=5)"</span>
<span class="diff-unchanged">      assert repr(node) == expected_repr</span>
<span class="diff-added">+ </span>
<span class="diff-added">+ </span>
<span class="diff-added">+ def test_start_equals_goal():</span>
<span class="diff-added">+     grid = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]</span>
<span class="diff-added">+     start = Node(1, 1, 0)</span>
<span class="diff-added">+     goal = Node(1, 1, 0)</span>
<span class="diff-added">+     planner = Dijkstra(grid)</span>
<span class="diff-added">+     found, path = planner.plan(start, goal)</span>
<span class="diff-added">+     assert found is True</span>
<span class="diff-added">+     assert path[0] == goal</span>
<span class="diff-added">+     assert path[-1] == start</span></code></pre>
                    </details>
                </td>
                <td>
                    <details>
                        <summary>View More</summary>
                        <div><strong>STDERR:</strong> <pre><code class="language-python"></code></pre></div>
                        <div><strong>STDOUT:</strong> <pre><code class="language-python">============================= test session starts ==============================
platform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0
rootdir: /home/thiuquan/code/maude/cover-agent/dijkstra
plugins: anyio-4.8.0, cov-6.0.0
collected 6 items

test_app.py ......                                                       [100%]

---------- coverage: platform linux, python 3.10.12-final-0 ----------
Name          Stmts   Miss Branch BrPart  Cover
-----------------------------------------------
app.py          106     17     32      3    86%
test_app.py      50      0      0      0   100%
-----------------------------------------------
TOTAL           156     17     32      3    89%
Coverage XML written to file coverage.xml


============================== 6 passed in 0.07s ===============================
</code></pre></div>
                        <div><strong>Test Code:</strong> <pre><code class="language-python">def test_start_equals_goal():
    grid = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]
    start = Node(1, 1, 0)
    goal = Node(1, 1, 0)
    planner = Dijkstra(grid)
    found, path = planner.plan(start, goal)
    assert found is True
    assert path[0] == goal
    assert path[-1] == start
</code></pre></div>
                        <div><strong>Imports:</strong> <pre><code class="language-python">""
</code></pre></div>
                    </details>
                </td>
            </tr>
            
            <tr>
                <td class="status-FAIL">FAIL</td>
                <td>Coverage did not increase</td>
                <td>0</td>
                <td>python</td>
                <td>
                    <details>
                        <summary>View Full Code</summary>
                        <pre><code><span class="diff-unchanged">  import pytest</span>
<span class="diff-unchanged">  from app import Node, Dijkstra</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_simple_path():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 1:</span>
<span class="diff-unchanged">      A simple 3x3 grid with no obstacles. The start is at (0,0) and the goal is at (2,2).</span>
<span class="diff-unchanged">      We expect the planner to find a path.</span>
<span class="diff-unchanged">      Note: The returned path is in reverse order (goal to start).</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 0, 0],</span>
<span class="diff-unchanged">          [0, 0, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">      </span>
<span class="diff-unchanged">      assert found is True, "Path should be found in a clear grid."</span>
<span class="diff-unchanged">      # Check that the path starts at the goal and ends at the start.</span>
<span class="diff-unchanged">      assert path[0] == goal, "Path should start with the goal node."</span>
<span class="diff-unchanged">      assert path[-1] == start, "Path should end with the start node."</span>
<span class="diff-unchanged">      # Optionally, check that the length of the path is reasonable (at least Manhattan distance + 1)</span>
<span class="diff-unchanged">      manhattan_distance = abs(goal.x - start.x) + abs(goal.y - start.y)</span>
<span class="diff-unchanged">      assert len(path) >= manhattan_distance + 1</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_no_path():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 2:</span>
<span class="diff-unchanged">      A 3x3 grid where the start is completely blocked off.</span>
<span class="diff-unchanged">      Start is at (0,0) and obstacles are placed so that there is no valid move.</span>
<span class="diff-unchanged">      The planner should return that no path is found.</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [1, 1, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">      assert found is False, "No path should be found if the start is blocked."</span>
<span class="diff-unchanged">      assert path == [], "Path should be empty when no path is found."</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_obstacle_detour():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 3:</span>
<span class="diff-unchanged">      A 3x3 grid with a vertical obstacle in the middle.</span>
<span class="diff-unchanged">      The start is at (0,0) and the goal is at (2,2). A detour is required.</span>
<span class="diff-unchanged">      We expect the planner to find a valid path.</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">      assert found is True, "A path should be found around the obstacle."</span>
<span class="diff-unchanged">      assert path[0] == goal, "Path should start with the goal node."</span>
<span class="diff-unchanged">      assert path[-1] == start, "Path should end with the start node."</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_goal_not_found():</span>
<span class="diff-unchanged">      planner = Dijkstra([[0]])</span>
<span class="diff-unchanged">      closed_list = set()</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(1, 1, 0)</span>
<span class="diff-unchanged">      path = planner.convert_closed_list_to_path(closed_list, start, goal)</span>
<span class="diff-unchanged">      assert path == []</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_node_repr():</span>
<span class="diff-unchanged">      node = Node(1, 2, 3, 4, 5)</span>
<span class="diff-unchanged">      expected_repr = "Node(x=1, y=2, cost=3, id=4, pid=5)"</span>
<span class="diff-unchanged">      assert repr(node) == expected_repr</span>
<span class="diff-added">+ </span>
<span class="diff-added">+ </span>
<span class="diff-added">+ def test_goal_unreachable_row_obstacle():</span>
<span class="diff-added">+     n = 3</span>
<span class="diff-added">+     grid = [</span>
<span class="diff-added">+         [0, 0, 0],</span>
<span class="diff-added">+         [1, 1, 1],</span>
<span class="diff-added">+         [0, 0, 0]</span>
<span class="diff-added">+     ]</span>
<span class="diff-added">+     start = Node(0, 0, 0)</span>
<span class="diff-added">+     goal = Node(2, 2, 0)</span>
<span class="diff-added">+     start.id = start.x * n + start.y</span>
<span class="diff-added">+     start.pid = start.id</span>
<span class="diff-added">+     goal.id = goal.x * n + goal.y</span>
<span class="diff-added">+     grid[start.x][start.y] = 0</span>
<span class="diff-added">+     grid[goal.x][goal.y] = 0</span>
<span class="diff-added">+ </span>
<span class="diff-added">+     planner = Dijkstra(grid)</span>
<span class="diff-added">+     found, path = planner.plan(start, goal)</span>
<span class="diff-added">+ </span>
<span class="diff-added">+     assert found is False</span>
<span class="diff-added">+     assert path == []</span></code></pre>
                    </details>
                </td>
                <td>
                    <details>
                        <summary>View More</summary>
                        <div><strong>STDERR:</strong> <pre><code class="language-python"></code></pre></div>
                        <div><strong>STDOUT:</strong> <pre><code class="language-python">============================= test session starts ==============================
platform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0
rootdir: /home/thiuquan/code/maude/cover-agent/dijkstra
plugins: anyio-4.8.0, cov-6.0.0
collected 6 items

test_app.py ......                                                       [100%]

---------- coverage: platform linux, python 3.10.12-final-0 ----------
Name          Stmts   Miss Branch BrPart  Cover
-----------------------------------------------
app.py          106     17     32      3    86%
test_app.py      55      0      0      0   100%
-----------------------------------------------
TOTAL           161     17     32      3    90%
Coverage XML written to file coverage.xml


============================== 6 passed in 0.08s ===============================
</code></pre></div>
                        <div><strong>Test Code:</strong> <pre><code class="language-python">def test_goal_unreachable_row_obstacle():
    n = 3
    grid = [
        [0, 0, 0],
        [1, 1, 1],
        [0, 0, 0]
    ]
    start = Node(0, 0, 0)
    goal = Node(2, 2, 0)
    start.id = start.x * n + start.y
    start.pid = start.id
    goal.id = goal.x * n + goal.y
    grid[start.x][start.y] = 0
    grid[goal.x][goal.y] = 0

    planner = Dijkstra(grid)
    found, path = planner.plan(start, goal)

    assert found is False
    assert path == []
</code></pre></div>
                        <div><strong>Imports:</strong> <pre><code class="language-python">""
</code></pre></div>
                    </details>
                </td>
            </tr>
            
            <tr>
                <td class="status-FAIL">FAIL</td>
                <td>Coverage did not increase</td>
                <td>0</td>
                <td>python</td>
                <td>
                    <details>
                        <summary>View Full Code</summary>
                        <pre><code><span class="diff-unchanged">  import pytest</span>
<span class="diff-unchanged">  from app import Node, Dijkstra</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_simple_path():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 1:</span>
<span class="diff-unchanged">      A simple 3x3 grid with no obstacles. The start is at (0,0) and the goal is at (2,2).</span>
<span class="diff-unchanged">      We expect the planner to find a path.</span>
<span class="diff-unchanged">      Note: The returned path is in reverse order (goal to start).</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 0, 0],</span>
<span class="diff-unchanged">          [0, 0, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">      </span>
<span class="diff-unchanged">      assert found is True, "Path should be found in a clear grid."</span>
<span class="diff-unchanged">      # Check that the path starts at the goal and ends at the start.</span>
<span class="diff-unchanged">      assert path[0] == goal, "Path should start with the goal node."</span>
<span class="diff-unchanged">      assert path[-1] == start, "Path should end with the start node."</span>
<span class="diff-unchanged">      # Optionally, check that the length of the path is reasonable (at least Manhattan distance + 1)</span>
<span class="diff-unchanged">      manhattan_distance = abs(goal.x - start.x) + abs(goal.y - start.y)</span>
<span class="diff-unchanged">      assert len(path) >= manhattan_distance + 1</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_no_path():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 2:</span>
<span class="diff-unchanged">      A 3x3 grid where the start is completely blocked off.</span>
<span class="diff-unchanged">      Start is at (0,0) and obstacles are placed so that there is no valid move.</span>
<span class="diff-unchanged">      The planner should return that no path is found.</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [1, 1, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">      assert found is False, "No path should be found if the start is blocked."</span>
<span class="diff-unchanged">      assert path == [], "Path should be empty when no path is found."</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_obstacle_detour():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 3:</span>
<span class="diff-unchanged">      A 3x3 grid with a vertical obstacle in the middle.</span>
<span class="diff-unchanged">      The start is at (0,0) and the goal is at (2,2). A detour is required.</span>
<span class="diff-unchanged">      We expect the planner to find a valid path.</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">      assert found is True, "A path should be found around the obstacle."</span>
<span class="diff-unchanged">      assert path[0] == goal, "Path should start with the goal node."</span>
<span class="diff-unchanged">      assert path[-1] == start, "Path should end with the start node."</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_goal_not_found():</span>
<span class="diff-unchanged">      planner = Dijkstra([[0]])</span>
<span class="diff-unchanged">      closed_list = set()</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(1, 1, 0)</span>
<span class="diff-unchanged">      path = planner.convert_closed_list_to_path(closed_list, start, goal)</span>
<span class="diff-unchanged">      assert path == []</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_node_repr():</span>
<span class="diff-unchanged">      node = Node(1, 2, 3, 4, 5)</span>
<span class="diff-unchanged">      expected_repr = "Node(x=1, y=2, cost=3, id=4, pid=5)"</span>
<span class="diff-unchanged">      assert repr(node) == expected_repr</span>
<span class="diff-added">+ </span>
<span class="diff-added">+ </span>
<span class="diff-added">+ def test_convert_closed_list_goal_not_in_closed_list():</span>
<span class="diff-added">+     planner = Dijkstra([[0]])</span>
<span class="diff-added">+     closed_list = {Node(0, 0)}</span>
<span class="diff-added">+     start = Node(0, 0, 0)</span>
<span class="diff-added">+     goal = Node(0, 1, 0)</span>
<span class="diff-added">+     path = planner.convert_closed_list_to_path(closed_list, start, goal)</span>
<span class="diff-added">+     assert path == []</span></code></pre>
                    </details>
                </td>
                <td>
                    <details>
                        <summary>View More</summary>
                        <div><strong>STDERR:</strong> <pre><code class="language-python"></code></pre></div>
                        <div><strong>STDOUT:</strong> <pre><code class="language-python">============================= test session starts ==============================
platform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0
rootdir: /home/thiuquan/code/maude/cover-agent/dijkstra
plugins: anyio-4.8.0, cov-6.0.0
collected 6 items

test_app.py ......                                                       [100%]

---------- coverage: platform linux, python 3.10.12-final-0 ----------
Name          Stmts   Miss Branch BrPart  Cover
-----------------------------------------------
app.py          106     17     32      3    86%
test_app.py      48      0      0      0   100%
-----------------------------------------------
TOTAL           154     17     32      3    89%
Coverage XML written to file coverage.xml


============================== 6 passed in 0.07s ===============================
</code></pre></div>
                        <div><strong>Test Code:</strong> <pre><code class="language-python">def test_convert_closed_list_goal_not_in_closed_list():
    planner = Dijkstra([[0]])
    closed_list = {Node(0, 0)}
    start = Node(0, 0, 0)
    goal = Node(0, 1, 0)
    path = planner.convert_closed_list_to_path(closed_list, start, goal)
    assert path == []
</code></pre></div>
                        <div><strong>Imports:</strong> <pre><code class="language-python">""
</code></pre></div>
                    </details>
                </td>
            </tr>
            
            <tr>
                <td class="status-FAIL">FAIL</td>
                <td>Test failed</td>
                <td>1</td>
                <td>python</td>
                <td>
                    <details>
                        <summary>View Full Code</summary>
                        <pre><code><span class="diff-unchanged">  import pytest</span>
<span class="diff-unchanged">  from app import Node, Dijkstra</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_simple_path():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 1:</span>
<span class="diff-unchanged">      A simple 3x3 grid with no obstacles. The start is at (0,0) and the goal is at (2,2).</span>
<span class="diff-unchanged">      We expect the planner to find a path.</span>
<span class="diff-unchanged">      Note: The returned path is in reverse order (goal to start).</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 0, 0],</span>
<span class="diff-unchanged">          [0, 0, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">      </span>
<span class="diff-unchanged">      assert found is True, "Path should be found in a clear grid."</span>
<span class="diff-unchanged">      # Check that the path starts at the goal and ends at the start.</span>
<span class="diff-unchanged">      assert path[0] == goal, "Path should start with the goal node."</span>
<span class="diff-unchanged">      assert path[-1] == start, "Path should end with the start node."</span>
<span class="diff-unchanged">      # Optionally, check that the length of the path is reasonable (at least Manhattan distance + 1)</span>
<span class="diff-unchanged">      manhattan_distance = abs(goal.x - start.x) + abs(goal.y - start.y)</span>
<span class="diff-unchanged">      assert len(path) >= manhattan_distance + 1</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_no_path():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 2:</span>
<span class="diff-unchanged">      A 3x3 grid where the start is completely blocked off.</span>
<span class="diff-unchanged">      Start is at (0,0) and obstacles are placed so that there is no valid move.</span>
<span class="diff-unchanged">      The planner should return that no path is found.</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [1, 1, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">      assert found is False, "No path should be found if the start is blocked."</span>
<span class="diff-unchanged">      assert path == [], "Path should be empty when no path is found."</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_obstacle_detour():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 3:</span>
<span class="diff-unchanged">      A 3x3 grid with a vertical obstacle in the middle.</span>
<span class="diff-unchanged">      The start is at (0,0) and the goal is at (2,2). A detour is required.</span>
<span class="diff-unchanged">      We expect the planner to find a valid path.</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">      assert found is True, "A path should be found around the obstacle."</span>
<span class="diff-unchanged">      assert path[0] == goal, "Path should start with the goal node."</span>
<span class="diff-unchanged">      assert path[-1] == start, "Path should end with the start node."</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_goal_not_found():</span>
<span class="diff-unchanged">      planner = Dijkstra([[0]])</span>
<span class="diff-unchanged">      closed_list = set()</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(1, 1, 0)</span>
<span class="diff-unchanged">      path = planner.convert_closed_list_to_path(closed_list, start, goal)</span>
<span class="diff-unchanged">      assert path == []</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_node_repr():</span>
<span class="diff-unchanged">      node = Node(1, 2, 3, 4, 5)</span>
<span class="diff-unchanged">      expected_repr = "Node(x=1, y=2, cost=3, id=4, pid=5)"</span>
<span class="diff-unchanged">      assert repr(node) == expected_repr</span>
<span class="diff-added">+ </span>
<span class="diff-added">+ </span>
<span class="diff-added">+ def test_convert_closed_list_parent_not_found():</span>
<span class="diff-added">+     planner = Dijkstra([[0, 0], [0, 0]])</span>
<span class="diff-added">+     start = Node(0, 0, 0)</span>
<span class="diff-added">+     goal = Node(1, 0, 0)</span>
<span class="diff-added">+     closed_list = {start, goal}</span>
<span class="diff-added">+     goal.pid = None</span>
<span class="diff-added">+ </span>
<span class="diff-added">+     path = planner.convert_closed_list_to_path(closed_list, start, goal)</span>
<span class="diff-added">+     assert path == []</span></code></pre>
                    </details>
                </td>
                <td>
                    <details>
                        <summary>View More</summary>
                        <div><strong>STDERR:</strong> <pre><code class="language-python"></code></pre></div>
                        <div><strong>STDOUT:</strong> <pre><code class="language-python">============================= test session starts ==============================
platform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0
rootdir: /home/thiuquan/code/maude/cover-agent/dijkstra
plugins: anyio-4.8.0, cov-6.0.0
collected 6 items

test_app.py .....F                                                       [100%]

=================================== FAILURES ===================================
__________________ test_convert_closed_list_parent_not_found ___________________

    def test_convert_closed_list_parent_not_found():
        planner = Dijkstra([[0, 0], [0, 0]])
        start = Node(0, 0, 0)
        goal = Node(1, 0, 0)
        closed_list = {start, goal}
        goal.pid = None
    
>       path = planner.convert_closed_list_to_path(closed_list, start, goal)

test_app.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <app.Dijkstra object at 0x7f3ab21c0ac0>
closed_list = {Node(x=1, y=0, cost=0, id=None, pid=None), Node(x=0, y=0, cost=0, id=None, pid=None)}
start = Node(x=0, y=0, cost=0, id=None, pid=None)
goal = Node(x=1, y=0, cost=0, id=None, pid=None)

    def convert_closed_list_to_path(self, closed_list, start, goal):
        """
        Converts the closed list (visited nodes) into a path from goal to start.
        Backtracks from the goal node using the stored parent ids (pid).
        """
        current = None
        # Find the node in closed_list that matches the goal coordinates.
        for node in closed_list:
            if compare_coordinates(node, goal):
                current = node
                break
    
        if current is None:
            print("Error in calculating path")
            return []
    
        path = []
        # Backtrack until we reach the start.
        while not compare_coordinates(current, start):
            path.append(current)
>           parent_x = current.pid // self.n
E           TypeError: unsupported operand type(s) for //: 'NoneType' and 'int'

app.py:144: TypeError

---------- coverage: platform linux, python 3.10.12-final-0 ----------
Name          Stmts   Miss Branch BrPart  Cover
-----------------------------------------------
app.py          106     17     32      3    86%
test_app.py      49      1      0      0    98%
-----------------------------------------------
TOTAL           155     18     32      3    89%
Coverage XML written to file coverage.xml

=========================== short test summary info ============================
FAILED test_app.py::test_convert_closed_list_parent_not_found - TypeError: un...
========================= 1 failed, 5 passed in 0.09s ==========================
</code></pre></div>
                        <div><strong>Test Code:</strong> <pre><code class="language-python">def test_convert_closed_list_parent_not_found():
    planner = Dijkstra([[0, 0], [0, 0]])
    start = Node(0, 0, 0)
    goal = Node(1, 0, 0)
    closed_list = {start, goal}
    goal.pid = None

    path = planner.convert_closed_list_to_path(closed_list, start, goal)
    assert path == []
</code></pre></div>
                        <div><strong>Imports:</strong> <pre><code class="language-python">""
</code></pre></div>
                    </details>
                </td>
            </tr>
            
            <tr>
                <td class="status-FAIL">FAIL</td>
                <td>Coverage did not increase</td>
                <td>0</td>
                <td>python</td>
                <td>
                    <details>
                        <summary>View Full Code</summary>
                        <pre><code><span class="diff-unchanged">  import pytest</span>
<span class="diff-unchanged">  from app import Node, Dijkstra</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_simple_path():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 1:</span>
<span class="diff-unchanged">      A simple 3x3 grid with no obstacles. The start is at (0,0) and the goal is at (2,2).</span>
<span class="diff-unchanged">      We expect the planner to find a path.</span>
<span class="diff-unchanged">      Note: The returned path is in reverse order (goal to start).</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 0, 0],</span>
<span class="diff-unchanged">          [0, 0, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">      </span>
<span class="diff-unchanged">      assert found is True, "Path should be found in a clear grid."</span>
<span class="diff-unchanged">      # Check that the path starts at the goal and ends at the start.</span>
<span class="diff-unchanged">      assert path[0] == goal, "Path should start with the goal node."</span>
<span class="diff-unchanged">      assert path[-1] == start, "Path should end with the start node."</span>
<span class="diff-unchanged">      # Optionally, check that the length of the path is reasonable (at least Manhattan distance + 1)</span>
<span class="diff-unchanged">      manhattan_distance = abs(goal.x - start.x) + abs(goal.y - start.y)</span>
<span class="diff-unchanged">      assert len(path) >= manhattan_distance + 1</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_no_path():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 2:</span>
<span class="diff-unchanged">      A 3x3 grid where the start is completely blocked off.</span>
<span class="diff-unchanged">      Start is at (0,0) and obstacles are placed so that there is no valid move.</span>
<span class="diff-unchanged">      The planner should return that no path is found.</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [1, 1, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">      assert found is False, "No path should be found if the start is blocked."</span>
<span class="diff-unchanged">      assert path == [], "Path should be empty when no path is found."</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_obstacle_detour():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 3:</span>
<span class="diff-unchanged">      A 3x3 grid with a vertical obstacle in the middle.</span>
<span class="diff-unchanged">      The start is at (0,0) and the goal is at (2,2). A detour is required.</span>
<span class="diff-unchanged">      We expect the planner to find a valid path.</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">      assert found is True, "A path should be found around the obstacle."</span>
<span class="diff-unchanged">      assert path[0] == goal, "Path should start with the goal node."</span>
<span class="diff-unchanged">      assert path[-1] == start, "Path should end with the start node."</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_goal_not_found():</span>
<span class="diff-unchanged">      planner = Dijkstra([[0]])</span>
<span class="diff-unchanged">      closed_list = set()</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(1, 1, 0)</span>
<span class="diff-unchanged">      path = planner.convert_closed_list_to_path(closed_list, start, goal)</span>
<span class="diff-unchanged">      assert path == []</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_node_repr():</span>
<span class="diff-unchanged">      node = Node(1, 2, 3, 4, 5)</span>
<span class="diff-unchanged">      expected_repr = "Node(x=1, y=2, cost=3, id=4, pid=5)"</span>
<span class="diff-unchanged">      assert repr(node) == expected_repr</span>
<span class="diff-added">+ </span>
<span class="diff-added">+ </span>
<span class="diff-added">+ def test_start_equals_goal():</span>
<span class="diff-added">+     grid = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]</span>
<span class="diff-added">+     start = Node(1, 1, 0)</span>
<span class="diff-added">+     goal = Node(1, 1, 0)</span>
<span class="diff-added">+     planner = Dijkstra(grid)</span>
<span class="diff-added">+     found, path = planner.plan(start, goal)</span>
<span class="diff-added">+     assert found is True</span>
<span class="diff-added">+     assert path[0] == goal</span>
<span class="diff-added">+     assert path[-1] == start</span></code></pre>
                    </details>
                </td>
                <td>
                    <details>
                        <summary>View More</summary>
                        <div><strong>STDERR:</strong> <pre><code class="language-python"></code></pre></div>
                        <div><strong>STDOUT:</strong> <pre><code class="language-python">============================= test session starts ==============================
platform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0
rootdir: /home/thiuquan/code/maude/cover-agent/dijkstra
plugins: anyio-4.8.0, cov-6.0.0
collected 6 items

test_app.py ......                                                       [100%]

---------- coverage: platform linux, python 3.10.12-final-0 ----------
Name          Stmts   Miss Branch BrPart  Cover
-----------------------------------------------
app.py          106     17     32      3    86%
test_app.py      50      0      0      0   100%
-----------------------------------------------
TOTAL           156     17     32      3    89%
Coverage XML written to file coverage.xml


============================== 6 passed in 0.07s ===============================
</code></pre></div>
                        <div><strong>Test Code:</strong> <pre><code class="language-python">def test_start_equals_goal():
    grid = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]
    start = Node(1, 1, 0)
    goal = Node(1, 1, 0)
    planner = Dijkstra(grid)
    found, path = planner.plan(start, goal)
    assert found is True
    assert path[0] == goal
    assert path[-1] == start
</code></pre></div>
                        <div><strong>Imports:</strong> <pre><code class="language-python">""
</code></pre></div>
                    </details>
                </td>
            </tr>
            
            <tr>
                <td class="status-FAIL">FAIL</td>
                <td>Coverage did not increase</td>
                <td>0</td>
                <td>python</td>
                <td>
                    <details>
                        <summary>View Full Code</summary>
                        <pre><code><span class="diff-unchanged">  import pytest</span>
<span class="diff-unchanged">  from app import Node, Dijkstra</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_simple_path():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 1:</span>
<span class="diff-unchanged">      A simple 3x3 grid with no obstacles. The start is at (0,0) and the goal is at (2,2).</span>
<span class="diff-unchanged">      We expect the planner to find a path.</span>
<span class="diff-unchanged">      Note: The returned path is in reverse order (goal to start).</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 0, 0],</span>
<span class="diff-unchanged">          [0, 0, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">      </span>
<span class="diff-unchanged">      assert found is True, "Path should be found in a clear grid."</span>
<span class="diff-unchanged">      # Check that the path starts at the goal and ends at the start.</span>
<span class="diff-unchanged">      assert path[0] == goal, "Path should start with the goal node."</span>
<span class="diff-unchanged">      assert path[-1] == start, "Path should end with the start node."</span>
<span class="diff-unchanged">      # Optionally, check that the length of the path is reasonable (at least Manhattan distance + 1)</span>
<span class="diff-unchanged">      manhattan_distance = abs(goal.x - start.x) + abs(goal.y - start.y)</span>
<span class="diff-unchanged">      assert len(path) >= manhattan_distance + 1</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_no_path():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 2:</span>
<span class="diff-unchanged">      A 3x3 grid where the start is completely blocked off.</span>
<span class="diff-unchanged">      Start is at (0,0) and obstacles are placed so that there is no valid move.</span>
<span class="diff-unchanged">      The planner should return that no path is found.</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [1, 1, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">      assert found is False, "No path should be found if the start is blocked."</span>
<span class="diff-unchanged">      assert path == [], "Path should be empty when no path is found."</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_obstacle_detour():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 3:</span>
<span class="diff-unchanged">      A 3x3 grid with a vertical obstacle in the middle.</span>
<span class="diff-unchanged">      The start is at (0,0) and the goal is at (2,2). A detour is required.</span>
<span class="diff-unchanged">      We expect the planner to find a valid path.</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">      assert found is True, "A path should be found around the obstacle."</span>
<span class="diff-unchanged">      assert path[0] == goal, "Path should start with the goal node."</span>
<span class="diff-unchanged">      assert path[-1] == start, "Path should end with the start node."</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_goal_not_found():</span>
<span class="diff-unchanged">      planner = Dijkstra([[0]])</span>
<span class="diff-unchanged">      closed_list = set()</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(1, 1, 0)</span>
<span class="diff-unchanged">      path = planner.convert_closed_list_to_path(closed_list, start, goal)</span>
<span class="diff-unchanged">      assert path == []</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_node_repr():</span>
<span class="diff-unchanged">      node = Node(1, 2, 3, 4, 5)</span>
<span class="diff-unchanged">      expected_repr = "Node(x=1, y=2, cost=3, id=4, pid=5)"</span>
<span class="diff-unchanged">      assert repr(node) == expected_repr</span>
<span class="diff-added">+ </span>
<span class="diff-added">+ </span>
<span class="diff-added">+ def test_goal_unreachable_row_obstacle():</span>
<span class="diff-added">+     n = 3</span>
<span class="diff-added">+     grid = [</span>
<span class="diff-added">+         [0, 0, 0],</span>
<span class="diff-added">+         [1, 1, 1],</span>
<span class="diff-added">+         [0, 0, 0]</span>
<span class="diff-added">+     ]</span>
<span class="diff-added">+     start = Node(0, 0, 0)</span>
<span class="diff-added">+     goal = Node(2, 2, 0)</span>
<span class="diff-added">+     start.id = start.x * n + start.y</span>
<span class="diff-added">+     start.pid = start.id</span>
<span class="diff-added">+     goal.id = goal.x * n + goal.y</span>
<span class="diff-added">+     grid[start.x][start.y] = 0</span>
<span class="diff-added">+     grid[goal.x][goal.y] = 0</span>
<span class="diff-added">+ </span>
<span class="diff-added">+     planner = Dijkstra(grid)</span>
<span class="diff-added">+     found, path = planner.plan(start, goal)</span>
<span class="diff-added">+ </span>
<span class="diff-added">+     assert found is False</span>
<span class="diff-added">+     assert path == []</span></code></pre>
                    </details>
                </td>
                <td>
                    <details>
                        <summary>View More</summary>
                        <div><strong>STDERR:</strong> <pre><code class="language-python"></code></pre></div>
                        <div><strong>STDOUT:</strong> <pre><code class="language-python">============================= test session starts ==============================
platform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0
rootdir: /home/thiuquan/code/maude/cover-agent/dijkstra
plugins: anyio-4.8.0, cov-6.0.0
collected 6 items

test_app.py ......                                                       [100%]

---------- coverage: platform linux, python 3.10.12-final-0 ----------
Name          Stmts   Miss Branch BrPart  Cover
-----------------------------------------------
app.py          106     17     32      3    86%
test_app.py      55      0      0      0   100%
-----------------------------------------------
TOTAL           161     17     32      3    90%
Coverage XML written to file coverage.xml


============================== 6 passed in 0.08s ===============================
</code></pre></div>
                        <div><strong>Test Code:</strong> <pre><code class="language-python">def test_goal_unreachable_row_obstacle():
    n = 3
    grid = [
        [0, 0, 0],
        [1, 1, 1],
        [0, 0, 0]
    ]
    start = Node(0, 0, 0)
    goal = Node(2, 2, 0)
    start.id = start.x * n + start.y
    start.pid = start.id
    goal.id = goal.x * n + goal.y
    grid[start.x][start.y] = 0
    grid[goal.x][goal.y] = 0

    planner = Dijkstra(grid)
    found, path = planner.plan(start, goal)

    assert found is False
    assert path == []
</code></pre></div>
                        <div><strong>Imports:</strong> <pre><code class="language-python">""
</code></pre></div>
                    </details>
                </td>
            </tr>
            
            <tr>
                <td class="status-FAIL">FAIL</td>
                <td>Coverage did not increase</td>
                <td>0</td>
                <td>python</td>
                <td>
                    <details>
                        <summary>View Full Code</summary>
                        <pre><code><span class="diff-unchanged">  import pytest</span>
<span class="diff-unchanged">  from app import Node, Dijkstra</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_simple_path():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 1:</span>
<span class="diff-unchanged">      A simple 3x3 grid with no obstacles. The start is at (0,0) and the goal is at (2,2).</span>
<span class="diff-unchanged">      We expect the planner to find a path.</span>
<span class="diff-unchanged">      Note: The returned path is in reverse order (goal to start).</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 0, 0],</span>
<span class="diff-unchanged">          [0, 0, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">      </span>
<span class="diff-unchanged">      assert found is True, "Path should be found in a clear grid."</span>
<span class="diff-unchanged">      # Check that the path starts at the goal and ends at the start.</span>
<span class="diff-unchanged">      assert path[0] == goal, "Path should start with the goal node."</span>
<span class="diff-unchanged">      assert path[-1] == start, "Path should end with the start node."</span>
<span class="diff-unchanged">      # Optionally, check that the length of the path is reasonable (at least Manhattan distance + 1)</span>
<span class="diff-unchanged">      manhattan_distance = abs(goal.x - start.x) + abs(goal.y - start.y)</span>
<span class="diff-unchanged">      assert len(path) >= manhattan_distance + 1</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_no_path():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 2:</span>
<span class="diff-unchanged">      A 3x3 grid where the start is completely blocked off.</span>
<span class="diff-unchanged">      Start is at (0,0) and obstacles are placed so that there is no valid move.</span>
<span class="diff-unchanged">      The planner should return that no path is found.</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [1, 1, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">      assert found is False, "No path should be found if the start is blocked."</span>
<span class="diff-unchanged">      assert path == [], "Path should be empty when no path is found."</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_obstacle_detour():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 3:</span>
<span class="diff-unchanged">      A 3x3 grid with a vertical obstacle in the middle.</span>
<span class="diff-unchanged">      The start is at (0,0) and the goal is at (2,2). A detour is required.</span>
<span class="diff-unchanged">      We expect the planner to find a valid path.</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">      assert found is True, "A path should be found around the obstacle."</span>
<span class="diff-unchanged">      assert path[0] == goal, "Path should start with the goal node."</span>
<span class="diff-unchanged">      assert path[-1] == start, "Path should end with the start node."</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_goal_not_found():</span>
<span class="diff-unchanged">      planner = Dijkstra([[0]])</span>
<span class="diff-unchanged">      closed_list = set()</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(1, 1, 0)</span>
<span class="diff-unchanged">      path = planner.convert_closed_list_to_path(closed_list, start, goal)</span>
<span class="diff-unchanged">      assert path == []</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_node_repr():</span>
<span class="diff-unchanged">      node = Node(1, 2, 3, 4, 5)</span>
<span class="diff-unchanged">      expected_repr = "Node(x=1, y=2, cost=3, id=4, pid=5)"</span>
<span class="diff-unchanged">      assert repr(node) == expected_repr</span>
<span class="diff-added">+ </span>
<span class="diff-added">+ </span>
<span class="diff-added">+ def test_convert_closed_list_goal_not_in_closed_list():</span>
<span class="diff-added">+     planner = Dijkstra([[0]])</span>
<span class="diff-added">+     closed_list = {Node(0, 0)}</span>
<span class="diff-added">+     start = Node(0, 0, 0)</span>
<span class="diff-added">+     goal = Node(0, 1, 0)</span>
<span class="diff-added">+     path = planner.convert_closed_list_to_path(closed_list, start, goal)</span>
<span class="diff-added">+     assert path == []</span></code></pre>
                    </details>
                </td>
                <td>
                    <details>
                        <summary>View More</summary>
                        <div><strong>STDERR:</strong> <pre><code class="language-python"></code></pre></div>
                        <div><strong>STDOUT:</strong> <pre><code class="language-python">============================= test session starts ==============================
platform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0
rootdir: /home/thiuquan/code/maude/cover-agent/dijkstra
plugins: anyio-4.8.0, cov-6.0.0
collected 6 items

test_app.py ......                                                       [100%]

---------- coverage: platform linux, python 3.10.12-final-0 ----------
Name          Stmts   Miss Branch BrPart  Cover
-----------------------------------------------
app.py          106     17     32      3    86%
test_app.py      48      0      0      0   100%
-----------------------------------------------
TOTAL           154     17     32      3    89%
Coverage XML written to file coverage.xml


============================== 6 passed in 0.08s ===============================
</code></pre></div>
                        <div><strong>Test Code:</strong> <pre><code class="language-python">def test_convert_closed_list_goal_not_in_closed_list():
    planner = Dijkstra([[0]])
    closed_list = {Node(0, 0)}
    start = Node(0, 0, 0)
    goal = Node(0, 1, 0)
    path = planner.convert_closed_list_to_path(closed_list, start, goal)
    assert path == []
</code></pre></div>
                        <div><strong>Imports:</strong> <pre><code class="language-python">""
</code></pre></div>
                    </details>
                </td>
            </tr>
            
            <tr>
                <td class="status-FAIL">FAIL</td>
                <td>Test failed</td>
                <td>1</td>
                <td>python</td>
                <td>
                    <details>
                        <summary>View Full Code</summary>
                        <pre><code><span class="diff-unchanged">  import pytest</span>
<span class="diff-unchanged">  from app import Node, Dijkstra</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_simple_path():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 1:</span>
<span class="diff-unchanged">      A simple 3x3 grid with no obstacles. The start is at (0,0) and the goal is at (2,2).</span>
<span class="diff-unchanged">      We expect the planner to find a path.</span>
<span class="diff-unchanged">      Note: The returned path is in reverse order (goal to start).</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 0, 0],</span>
<span class="diff-unchanged">          [0, 0, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">      </span>
<span class="diff-unchanged">      assert found is True, "Path should be found in a clear grid."</span>
<span class="diff-unchanged">      # Check that the path starts at the goal and ends at the start.</span>
<span class="diff-unchanged">      assert path[0] == goal, "Path should start with the goal node."</span>
<span class="diff-unchanged">      assert path[-1] == start, "Path should end with the start node."</span>
<span class="diff-unchanged">      # Optionally, check that the length of the path is reasonable (at least Manhattan distance + 1)</span>
<span class="diff-unchanged">      manhattan_distance = abs(goal.x - start.x) + abs(goal.y - start.y)</span>
<span class="diff-unchanged">      assert len(path) >= manhattan_distance + 1</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_no_path():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 2:</span>
<span class="diff-unchanged">      A 3x3 grid where the start is completely blocked off.</span>
<span class="diff-unchanged">      Start is at (0,0) and obstacles are placed so that there is no valid move.</span>
<span class="diff-unchanged">      The planner should return that no path is found.</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [1, 1, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">      assert found is False, "No path should be found if the start is blocked."</span>
<span class="diff-unchanged">      assert path == [], "Path should be empty when no path is found."</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_obstacle_detour():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 3:</span>
<span class="diff-unchanged">      A 3x3 grid with a vertical obstacle in the middle.</span>
<span class="diff-unchanged">      The start is at (0,0) and the goal is at (2,2). A detour is required.</span>
<span class="diff-unchanged">      We expect the planner to find a valid path.</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">      assert found is True, "A path should be found around the obstacle."</span>
<span class="diff-unchanged">      assert path[0] == goal, "Path should start with the goal node."</span>
<span class="diff-unchanged">      assert path[-1] == start, "Path should end with the start node."</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_goal_not_found():</span>
<span class="diff-unchanged">      planner = Dijkstra([[0]])</span>
<span class="diff-unchanged">      closed_list = set()</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(1, 1, 0)</span>
<span class="diff-unchanged">      path = planner.convert_closed_list_to_path(closed_list, start, goal)</span>
<span class="diff-unchanged">      assert path == []</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_node_repr():</span>
<span class="diff-unchanged">      node = Node(1, 2, 3, 4, 5)</span>
<span class="diff-unchanged">      expected_repr = "Node(x=1, y=2, cost=3, id=4, pid=5)"</span>
<span class="diff-unchanged">      assert repr(node) == expected_repr</span>
<span class="diff-added">+ </span>
<span class="diff-added">+ </span>
<span class="diff-added">+ def test_convert_closed_list_parent_not_found():</span>
<span class="diff-added">+     planner = Dijkstra([[0, 0], [0, 0]])</span>
<span class="diff-added">+     start = Node(0, 0, 0)</span>
<span class="diff-added">+     goal = Node(1, 0, 0)</span>
<span class="diff-added">+     closed_list = {start, goal}</span>
<span class="diff-added">+     goal.pid = None</span>
<span class="diff-added">+ </span>
<span class="diff-added">+     path = planner.convert_closed_list_to_path(closed_list, start, goal)</span>
<span class="diff-added">+     assert path == []</span></code></pre>
                    </details>
                </td>
                <td>
                    <details>
                        <summary>View More</summary>
                        <div><strong>STDERR:</strong> <pre><code class="language-python"></code></pre></div>
                        <div><strong>STDOUT:</strong> <pre><code class="language-python">============================= test session starts ==============================
platform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0
rootdir: /home/thiuquan/code/maude/cover-agent/dijkstra
plugins: anyio-4.8.0, cov-6.0.0
collected 6 items

test_app.py .....F                                                       [100%]

=================================== FAILURES ===================================
__________________ test_convert_closed_list_parent_not_found ___________________

    def test_convert_closed_list_parent_not_found():
        planner = Dijkstra([[0, 0], [0, 0]])
        start = Node(0, 0, 0)
        goal = Node(1, 0, 0)
        closed_list = {start, goal}
        goal.pid = None
    
>       path = planner.convert_closed_list_to_path(closed_list, start, goal)

test_app.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <app.Dijkstra object at 0x7f70333f0ac0>
closed_list = {Node(x=1, y=0, cost=0, id=None, pid=None), Node(x=0, y=0, cost=0, id=None, pid=None)}
start = Node(x=0, y=0, cost=0, id=None, pid=None)
goal = Node(x=1, y=0, cost=0, id=None, pid=None)

    def convert_closed_list_to_path(self, closed_list, start, goal):
        """
        Converts the closed list (visited nodes) into a path from goal to start.
        Backtracks from the goal node using the stored parent ids (pid).
        """
        current = None
        # Find the node in closed_list that matches the goal coordinates.
        for node in closed_list:
            if compare_coordinates(node, goal):
                current = node
                break
    
        if current is None:
            print("Error in calculating path")
            return []
    
        path = []
        # Backtrack until we reach the start.
        while not compare_coordinates(current, start):
            path.append(current)
>           parent_x = current.pid // self.n
E           TypeError: unsupported operand type(s) for //: 'NoneType' and 'int'

app.py:144: TypeError

---------- coverage: platform linux, python 3.10.12-final-0 ----------
Name          Stmts   Miss Branch BrPart  Cover
-----------------------------------------------
app.py          106     17     32      3    86%
test_app.py      49      1      0      0    98%
-----------------------------------------------
TOTAL           155     18     32      3    89%
Coverage XML written to file coverage.xml

=========================== short test summary info ============================
FAILED test_app.py::test_convert_closed_list_parent_not_found - TypeError: un...
========================= 1 failed, 5 passed in 0.08s ==========================
</code></pre></div>
                        <div><strong>Test Code:</strong> <pre><code class="language-python">def test_convert_closed_list_parent_not_found():
    planner = Dijkstra([[0, 0], [0, 0]])
    start = Node(0, 0, 0)
    goal = Node(1, 0, 0)
    closed_list = {start, goal}
    goal.pid = None

    path = planner.convert_closed_list_to_path(closed_list, start, goal)
    assert path == []
</code></pre></div>
                        <div><strong>Imports:</strong> <pre><code class="language-python">""
</code></pre></div>
                    </details>
                </td>
            </tr>
            
            <tr>
                <td class="status-FAIL">FAIL</td>
                <td>Coverage did not increase</td>
                <td>0</td>
                <td>python</td>
                <td>
                    <details>
                        <summary>View Full Code</summary>
                        <pre><code><span class="diff-unchanged">  import pytest</span>
<span class="diff-unchanged">  from app import Node, Dijkstra</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_simple_path():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 1:</span>
<span class="diff-unchanged">      A simple 3x3 grid with no obstacles. The start is at (0,0) and the goal is at (2,2).</span>
<span class="diff-unchanged">      We expect the planner to find a path.</span>
<span class="diff-unchanged">      Note: The returned path is in reverse order (goal to start).</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 0, 0],</span>
<span class="diff-unchanged">          [0, 0, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">      </span>
<span class="diff-unchanged">      assert found is True, "Path should be found in a clear grid."</span>
<span class="diff-unchanged">      # Check that the path starts at the goal and ends at the start.</span>
<span class="diff-unchanged">      assert path[0] == goal, "Path should start with the goal node."</span>
<span class="diff-unchanged">      assert path[-1] == start, "Path should end with the start node."</span>
<span class="diff-unchanged">      # Optionally, check that the length of the path is reasonable (at least Manhattan distance + 1)</span>
<span class="diff-unchanged">      manhattan_distance = abs(goal.x - start.x) + abs(goal.y - start.y)</span>
<span class="diff-unchanged">      assert len(path) >= manhattan_distance + 1</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_no_path():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 2:</span>
<span class="diff-unchanged">      A 3x3 grid where the start is completely blocked off.</span>
<span class="diff-unchanged">      Start is at (0,0) and obstacles are placed so that there is no valid move.</span>
<span class="diff-unchanged">      The planner should return that no path is found.</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [1, 1, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">      assert found is False, "No path should be found if the start is blocked."</span>
<span class="diff-unchanged">      assert path == [], "Path should be empty when no path is found."</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_obstacle_detour():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 3:</span>
<span class="diff-unchanged">      A 3x3 grid with a vertical obstacle in the middle.</span>
<span class="diff-unchanged">      The start is at (0,0) and the goal is at (2,2). A detour is required.</span>
<span class="diff-unchanged">      We expect the planner to find a valid path.</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">      assert found is True, "A path should be found around the obstacle."</span>
<span class="diff-unchanged">      assert path[0] == goal, "Path should start with the goal node."</span>
<span class="diff-unchanged">      assert path[-1] == start, "Path should end with the start node."</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_goal_not_found():</span>
<span class="diff-unchanged">      planner = Dijkstra([[0]])</span>
<span class="diff-unchanged">      closed_list = set()</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(1, 1, 0)</span>
<span class="diff-unchanged">      path = planner.convert_closed_list_to_path(closed_list, start, goal)</span>
<span class="diff-unchanged">      assert path == []</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_node_repr():</span>
<span class="diff-unchanged">      node = Node(1, 2, 3, 4, 5)</span>
<span class="diff-unchanged">      expected_repr = "Node(x=1, y=2, cost=3, id=4, pid=5)"</span>
<span class="diff-unchanged">      assert repr(node) == expected_repr</span>
<span class="diff-added">+ </span>
<span class="diff-added">+ </span>
<span class="diff-added">+ def test_start_equals_goal():</span>
<span class="diff-added">+     grid = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]</span>
<span class="diff-added">+     start = Node(1, 1, 0)</span>
<span class="diff-added">+     goal = Node(1, 1, 0)</span>
<span class="diff-added">+     planner = Dijkstra(grid)</span>
<span class="diff-added">+     found, path = planner.plan(start, goal)</span>
<span class="diff-added">+     assert found is True</span>
<span class="diff-added">+     assert path[0] == goal</span>
<span class="diff-added">+     assert path[-1] == start</span></code></pre>
                    </details>
                </td>
                <td>
                    <details>
                        <summary>View More</summary>
                        <div><strong>STDERR:</strong> <pre><code class="language-python"></code></pre></div>
                        <div><strong>STDOUT:</strong> <pre><code class="language-python">============================= test session starts ==============================
platform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0
rootdir: /home/thiuquan/code/maude/cover-agent/dijkstra
plugins: anyio-4.8.0, cov-6.0.0
collected 6 items

test_app.py ......                                                       [100%]

---------- coverage: platform linux, python 3.10.12-final-0 ----------
Name          Stmts   Miss Branch BrPart  Cover
-----------------------------------------------
app.py          106     17     32      3    86%
test_app.py      50      0      0      0   100%
-----------------------------------------------
TOTAL           156     17     32      3    89%
Coverage XML written to file coverage.xml


============================== 6 passed in 0.07s ===============================
</code></pre></div>
                        <div><strong>Test Code:</strong> <pre><code class="language-python">def test_start_equals_goal():
    grid = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]
    start = Node(1, 1, 0)
    goal = Node(1, 1, 0)
    planner = Dijkstra(grid)
    found, path = planner.plan(start, goal)
    assert found is True
    assert path[0] == goal
    assert path[-1] == start
</code></pre></div>
                        <div><strong>Imports:</strong> <pre><code class="language-python">""
</code></pre></div>
                    </details>
                </td>
            </tr>
            
            <tr>
                <td class="status-FAIL">FAIL</td>
                <td>Coverage did not increase</td>
                <td>0</td>
                <td>python</td>
                <td>
                    <details>
                        <summary>View Full Code</summary>
                        <pre><code><span class="diff-unchanged">  import pytest</span>
<span class="diff-unchanged">  from app import Node, Dijkstra</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_simple_path():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 1:</span>
<span class="diff-unchanged">      A simple 3x3 grid with no obstacles. The start is at (0,0) and the goal is at (2,2).</span>
<span class="diff-unchanged">      We expect the planner to find a path.</span>
<span class="diff-unchanged">      Note: The returned path is in reverse order (goal to start).</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 0, 0],</span>
<span class="diff-unchanged">          [0, 0, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">      </span>
<span class="diff-unchanged">      assert found is True, "Path should be found in a clear grid."</span>
<span class="diff-unchanged">      # Check that the path starts at the goal and ends at the start.</span>
<span class="diff-unchanged">      assert path[0] == goal, "Path should start with the goal node."</span>
<span class="diff-unchanged">      assert path[-1] == start, "Path should end with the start node."</span>
<span class="diff-unchanged">      # Optionally, check that the length of the path is reasonable (at least Manhattan distance + 1)</span>
<span class="diff-unchanged">      manhattan_distance = abs(goal.x - start.x) + abs(goal.y - start.y)</span>
<span class="diff-unchanged">      assert len(path) >= manhattan_distance + 1</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_no_path():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 2:</span>
<span class="diff-unchanged">      A 3x3 grid where the start is completely blocked off.</span>
<span class="diff-unchanged">      Start is at (0,0) and obstacles are placed so that there is no valid move.</span>
<span class="diff-unchanged">      The planner should return that no path is found.</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [1, 1, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">      assert found is False, "No path should be found if the start is blocked."</span>
<span class="diff-unchanged">      assert path == [], "Path should be empty when no path is found."</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_obstacle_detour():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 3:</span>
<span class="diff-unchanged">      A 3x3 grid with a vertical obstacle in the middle.</span>
<span class="diff-unchanged">      The start is at (0,0) and the goal is at (2,2). A detour is required.</span>
<span class="diff-unchanged">      We expect the planner to find a valid path.</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">      assert found is True, "A path should be found around the obstacle."</span>
<span class="diff-unchanged">      assert path[0] == goal, "Path should start with the goal node."</span>
<span class="diff-unchanged">      assert path[-1] == start, "Path should end with the start node."</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_goal_not_found():</span>
<span class="diff-unchanged">      planner = Dijkstra([[0]])</span>
<span class="diff-unchanged">      closed_list = set()</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(1, 1, 0)</span>
<span class="diff-unchanged">      path = planner.convert_closed_list_to_path(closed_list, start, goal)</span>
<span class="diff-unchanged">      assert path == []</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_node_repr():</span>
<span class="diff-unchanged">      node = Node(1, 2, 3, 4, 5)</span>
<span class="diff-unchanged">      expected_repr = "Node(x=1, y=2, cost=3, id=4, pid=5)"</span>
<span class="diff-unchanged">      assert repr(node) == expected_repr</span>
<span class="diff-added">+ </span>
<span class="diff-added">+ </span>
<span class="diff-added">+ def test_goal_unreachable_row_obstacle():</span>
<span class="diff-added">+     n = 3</span>
<span class="diff-added">+     grid = [</span>
<span class="diff-added">+         [0, 0, 0],</span>
<span class="diff-added">+         [1, 1, 1],</span>
<span class="diff-added">+         [0, 0, 0]</span>
<span class="diff-added">+     ]</span>
<span class="diff-added">+     start = Node(0, 0, 0)</span>
<span class="diff-added">+     goal = Node(2, 2, 0)</span>
<span class="diff-added">+     start.id = start.x * n + start.y</span>
<span class="diff-added">+     start.pid = start.id</span>
<span class="diff-added">+     goal.id = goal.x * n + goal.y</span>
<span class="diff-added">+     grid[start.x][start.y] = 0</span>
<span class="diff-added">+     grid[goal.x][goal.y] = 0</span>
<span class="diff-added">+ </span>
<span class="diff-added">+     planner = Dijkstra(grid)</span>
<span class="diff-added">+     found, path = planner.plan(start, goal)</span>
<span class="diff-added">+ </span>
<span class="diff-added">+     assert found is False</span>
<span class="diff-added">+     assert path == []</span></code></pre>
                    </details>
                </td>
                <td>
                    <details>
                        <summary>View More</summary>
                        <div><strong>STDERR:</strong> <pre><code class="language-python"></code></pre></div>
                        <div><strong>STDOUT:</strong> <pre><code class="language-python">============================= test session starts ==============================
platform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0
rootdir: /home/thiuquan/code/maude/cover-agent/dijkstra
plugins: anyio-4.8.0, cov-6.0.0
collected 6 items

test_app.py ......                                                       [100%]

---------- coverage: platform linux, python 3.10.12-final-0 ----------
Name          Stmts   Miss Branch BrPart  Cover
-----------------------------------------------
app.py          106     17     32      3    86%
test_app.py      55      0      0      0   100%
-----------------------------------------------
TOTAL           161     17     32      3    90%
Coverage XML written to file coverage.xml


============================== 6 passed in 0.07s ===============================
</code></pre></div>
                        <div><strong>Test Code:</strong> <pre><code class="language-python">def test_goal_unreachable_row_obstacle():
    n = 3
    grid = [
        [0, 0, 0],
        [1, 1, 1],
        [0, 0, 0]
    ]
    start = Node(0, 0, 0)
    goal = Node(2, 2, 0)
    start.id = start.x * n + start.y
    start.pid = start.id
    goal.id = goal.x * n + goal.y
    grid[start.x][start.y] = 0
    grid[goal.x][goal.y] = 0

    planner = Dijkstra(grid)
    found, path = planner.plan(start, goal)

    assert found is False
    assert path == []
</code></pre></div>
                        <div><strong>Imports:</strong> <pre><code class="language-python">""
</code></pre></div>
                    </details>
                </td>
            </tr>
            
            <tr>
                <td class="status-FAIL">FAIL</td>
                <td>Coverage did not increase</td>
                <td>0</td>
                <td>python</td>
                <td>
                    <details>
                        <summary>View Full Code</summary>
                        <pre><code><span class="diff-unchanged">  import pytest</span>
<span class="diff-unchanged">  from app import Node, Dijkstra</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_simple_path():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 1:</span>
<span class="diff-unchanged">      A simple 3x3 grid with no obstacles. The start is at (0,0) and the goal is at (2,2).</span>
<span class="diff-unchanged">      We expect the planner to find a path.</span>
<span class="diff-unchanged">      Note: The returned path is in reverse order (goal to start).</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 0, 0],</span>
<span class="diff-unchanged">          [0, 0, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">      </span>
<span class="diff-unchanged">      assert found is True, "Path should be found in a clear grid."</span>
<span class="diff-unchanged">      # Check that the path starts at the goal and ends at the start.</span>
<span class="diff-unchanged">      assert path[0] == goal, "Path should start with the goal node."</span>
<span class="diff-unchanged">      assert path[-1] == start, "Path should end with the start node."</span>
<span class="diff-unchanged">      # Optionally, check that the length of the path is reasonable (at least Manhattan distance + 1)</span>
<span class="diff-unchanged">      manhattan_distance = abs(goal.x - start.x) + abs(goal.y - start.y)</span>
<span class="diff-unchanged">      assert len(path) >= manhattan_distance + 1</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_no_path():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 2:</span>
<span class="diff-unchanged">      A 3x3 grid where the start is completely blocked off.</span>
<span class="diff-unchanged">      Start is at (0,0) and obstacles are placed so that there is no valid move.</span>
<span class="diff-unchanged">      The planner should return that no path is found.</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [1, 1, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">      assert found is False, "No path should be found if the start is blocked."</span>
<span class="diff-unchanged">      assert path == [], "Path should be empty when no path is found."</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_obstacle_detour():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 3:</span>
<span class="diff-unchanged">      A 3x3 grid with a vertical obstacle in the middle.</span>
<span class="diff-unchanged">      The start is at (0,0) and the goal is at (2,2). A detour is required.</span>
<span class="diff-unchanged">      We expect the planner to find a valid path.</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">      assert found is True, "A path should be found around the obstacle."</span>
<span class="diff-unchanged">      assert path[0] == goal, "Path should start with the goal node."</span>
<span class="diff-unchanged">      assert path[-1] == start, "Path should end with the start node."</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_goal_not_found():</span>
<span class="diff-unchanged">      planner = Dijkstra([[0]])</span>
<span class="diff-unchanged">      closed_list = set()</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(1, 1, 0)</span>
<span class="diff-unchanged">      path = planner.convert_closed_list_to_path(closed_list, start, goal)</span>
<span class="diff-unchanged">      assert path == []</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_node_repr():</span>
<span class="diff-unchanged">      node = Node(1, 2, 3, 4, 5)</span>
<span class="diff-unchanged">      expected_repr = "Node(x=1, y=2, cost=3, id=4, pid=5)"</span>
<span class="diff-unchanged">      assert repr(node) == expected_repr</span>
<span class="diff-added">+ </span>
<span class="diff-added">+ </span>
<span class="diff-added">+ def test_convert_closed_list_goal_not_in_closed_list():</span>
<span class="diff-added">+     planner = Dijkstra([[0]])</span>
<span class="diff-added">+     closed_list = {Node(0, 0)}</span>
<span class="diff-added">+     start = Node(0, 0, 0)</span>
<span class="diff-added">+     goal = Node(0, 1, 0)</span>
<span class="diff-added">+     path = planner.convert_closed_list_to_path(closed_list, start, goal)</span>
<span class="diff-added">+     assert path == []</span></code></pre>
                    </details>
                </td>
                <td>
                    <details>
                        <summary>View More</summary>
                        <div><strong>STDERR:</strong> <pre><code class="language-python"></code></pre></div>
                        <div><strong>STDOUT:</strong> <pre><code class="language-python">============================= test session starts ==============================
platform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0
rootdir: /home/thiuquan/code/maude/cover-agent/dijkstra
plugins: anyio-4.8.0, cov-6.0.0
collected 6 items

test_app.py ......                                                       [100%]

---------- coverage: platform linux, python 3.10.12-final-0 ----------
Name          Stmts   Miss Branch BrPart  Cover
-----------------------------------------------
app.py          106     17     32      3    86%
test_app.py      48      0      0      0   100%
-----------------------------------------------
TOTAL           154     17     32      3    89%
Coverage XML written to file coverage.xml


============================== 6 passed in 0.08s ===============================
</code></pre></div>
                        <div><strong>Test Code:</strong> <pre><code class="language-python">def test_convert_closed_list_goal_not_in_closed_list():
    planner = Dijkstra([[0]])
    closed_list = {Node(0, 0)}
    start = Node(0, 0, 0)
    goal = Node(0, 1, 0)
    path = planner.convert_closed_list_to_path(closed_list, start, goal)
    assert path == []
</code></pre></div>
                        <div><strong>Imports:</strong> <pre><code class="language-python">""
</code></pre></div>
                    </details>
                </td>
            </tr>
            
            <tr>
                <td class="status-FAIL">FAIL</td>
                <td>Test failed</td>
                <td>1</td>
                <td>python</td>
                <td>
                    <details>
                        <summary>View Full Code</summary>
                        <pre><code><span class="diff-unchanged">  import pytest</span>
<span class="diff-unchanged">  from app import Node, Dijkstra</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_simple_path():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 1:</span>
<span class="diff-unchanged">      A simple 3x3 grid with no obstacles. The start is at (0,0) and the goal is at (2,2).</span>
<span class="diff-unchanged">      We expect the planner to find a path.</span>
<span class="diff-unchanged">      Note: The returned path is in reverse order (goal to start).</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 0, 0],</span>
<span class="diff-unchanged">          [0, 0, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">      </span>
<span class="diff-unchanged">      assert found is True, "Path should be found in a clear grid."</span>
<span class="diff-unchanged">      # Check that the path starts at the goal and ends at the start.</span>
<span class="diff-unchanged">      assert path[0] == goal, "Path should start with the goal node."</span>
<span class="diff-unchanged">      assert path[-1] == start, "Path should end with the start node."</span>
<span class="diff-unchanged">      # Optionally, check that the length of the path is reasonable (at least Manhattan distance + 1)</span>
<span class="diff-unchanged">      manhattan_distance = abs(goal.x - start.x) + abs(goal.y - start.y)</span>
<span class="diff-unchanged">      assert len(path) >= manhattan_distance + 1</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_no_path():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 2:</span>
<span class="diff-unchanged">      A 3x3 grid where the start is completely blocked off.</span>
<span class="diff-unchanged">      Start is at (0,0) and obstacles are placed so that there is no valid move.</span>
<span class="diff-unchanged">      The planner should return that no path is found.</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [1, 1, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">      assert found is False, "No path should be found if the start is blocked."</span>
<span class="diff-unchanged">      assert path == [], "Path should be empty when no path is found."</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_obstacle_detour():</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      Test case 3:</span>
<span class="diff-unchanged">      A 3x3 grid with a vertical obstacle in the middle.</span>
<span class="diff-unchanged">      The start is at (0,0) and the goal is at (2,2). A detour is required.</span>
<span class="diff-unchanged">      We expect the planner to find a valid path.</span>
<span class="diff-unchanged">      """</span>
<span class="diff-unchanged">      grid = [</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [0, 1, 0],</span>
<span class="diff-unchanged">          [0, 0, 0]</span>
<span class="diff-unchanged">      ]</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(2, 2, 0)</span>
<span class="diff-unchanged">      planner = Dijkstra(grid)</span>
<span class="diff-unchanged">      found, path = planner.plan(start, goal)</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">      assert found is True, "A path should be found around the obstacle."</span>
<span class="diff-unchanged">      assert path[0] == goal, "Path should start with the goal node."</span>
<span class="diff-unchanged">      assert path[-1] == start, "Path should end with the start node."</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_goal_not_found():</span>
<span class="diff-unchanged">      planner = Dijkstra([[0]])</span>
<span class="diff-unchanged">      closed_list = set()</span>
<span class="diff-unchanged">      start = Node(0, 0, 0)</span>
<span class="diff-unchanged">      goal = Node(1, 1, 0)</span>
<span class="diff-unchanged">      path = planner.convert_closed_list_to_path(closed_list, start, goal)</span>
<span class="diff-unchanged">      assert path == []</span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  </span>
<span class="diff-unchanged">  def test_node_repr():</span>
<span class="diff-unchanged">      node = Node(1, 2, 3, 4, 5)</span>
<span class="diff-unchanged">      expected_repr = "Node(x=1, y=2, cost=3, id=4, pid=5)"</span>
<span class="diff-unchanged">      assert repr(node) == expected_repr</span>
<span class="diff-added">+ </span>
<span class="diff-added">+ </span>
<span class="diff-added">+ def test_convert_closed_list_parent_not_found():</span>
<span class="diff-added">+     planner = Dijkstra([[0, 0], [0, 0]])</span>
<span class="diff-added">+     start = Node(0, 0, 0)</span>
<span class="diff-added">+     goal = Node(1, 0, 0)</span>
<span class="diff-added">+     closed_list = {start, goal}</span>
<span class="diff-added">+     goal.pid = None</span>
<span class="diff-added">+ </span>
<span class="diff-added">+     path = planner.convert_closed_list_to_path(closed_list, start, goal)</span>
<span class="diff-added">+     assert path == []</span></code></pre>
                    </details>
                </td>
                <td>
                    <details>
                        <summary>View More</summary>
                        <div><strong>STDERR:</strong> <pre><code class="language-python"></code></pre></div>
                        <div><strong>STDOUT:</strong> <pre><code class="language-python">============================= test session starts ==============================
platform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0
rootdir: /home/thiuquan/code/maude/cover-agent/dijkstra
plugins: anyio-4.8.0, cov-6.0.0
collected 6 items

test_app.py .....F                                                       [100%]

=================================== FAILURES ===================================
__________________ test_convert_closed_list_parent_not_found ___________________

    def test_convert_closed_list_parent_not_found():
        planner = Dijkstra([[0, 0], [0, 0]])
        start = Node(0, 0, 0)
        goal = Node(1, 0, 0)
        closed_list = {start, goal}
        goal.pid = None
    
>       path = planner.convert_closed_list_to_path(closed_list, start, goal)

test_app.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <app.Dijkstra object at 0x7f0e063a4ac0>
closed_list = {Node(x=1, y=0, cost=0, id=None, pid=None), Node(x=0, y=0, cost=0, id=None, pid=None)}
start = Node(x=0, y=0, cost=0, id=None, pid=None)
goal = Node(x=1, y=0, cost=0, id=None, pid=None)

    def convert_closed_list_to_path(self, closed_list, start, goal):
        """
        Converts the closed list (visited nodes) into a path from goal to start.
        Backtracks from the goal node using the stored parent ids (pid).
        """
        current = None
        # Find the node in closed_list that matches the goal coordinates.
        for node in closed_list:
            if compare_coordinates(node, goal):
                current = node
                break
    
        if current is None:
            print("Error in calculating path")
            return []
    
        path = []
        # Backtrack until we reach the start.
        while not compare_coordinates(current, start):
            path.append(current)
>           parent_x = current.pid // self.n
E           TypeError: unsupported operand type(s) for //: 'NoneType' and 'int'

app.py:144: TypeError

---------- coverage: platform linux, python 3.10.12-final-0 ----------
Name          Stmts   Miss Branch BrPart  Cover
-----------------------------------------------
app.py          106     17     32      3    86%
test_app.py      49      1      0      0    98%
-----------------------------------------------
TOTAL           155     18     32      3    89%
Coverage XML written to file coverage.xml

=========================== short test summary info ============================
FAILED test_app.py::test_convert_closed_list_parent_not_found - TypeError: un...
========================= 1 failed, 5 passed in 0.11s ==========================
</code></pre></div>
                        <div><strong>Test Code:</strong> <pre><code class="language-python">def test_convert_closed_list_parent_not_found():
    planner = Dijkstra([[0, 0], [0, 0]])
    start = Node(0, 0, 0)
    goal = Node(1, 0, 0)
    closed_list = {start, goal}
    goal.pid = None

    path = planner.convert_closed_list_to_path(closed_list, start, goal)
    assert path == []
</code></pre></div>
                        <div><strong>Imports:</strong> <pre><code class="language-python">""
</code></pre></div>
                    </details>
                </td>
            </tr>
            
        </table>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/prism.min.js"></script>
    </body>
    </html>
    